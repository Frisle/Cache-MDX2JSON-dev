<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="25">
<Class name="%DeepSee.ResultSet">
<Description><![CDATA[
This class provides an API for executing queries against DeepSee cubes 
and viewing the results.<br/>
This class extends Zen data model so that it can efficiently
work within the Zen MVC framework.]]></Description>
<IncludeCode>%DeepSee</IncludeCode>
<Super>%ZEN.DataModel.DataModel</Super>
<System>4</System>
<TimeCreated>61173,60740.399507</TimeCreated>

<Property name="%Trace">
<Description>
Debugging flag. If true write out tracing information to the console.</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="%Query">
<Description>
Run-time query object that will serve as the source for this result set.</Description>
<Type>%DeepSee.Query.query</Type>
<Internal>1</Internal>
</Property>

<Property name="%Cube">
<Description>
Name of the cube this query is based on.</Description>
<Type>%DeepSee.Datatype.string</Type>
<Internal>1</Internal>
</Property>

<Property name="%CubeKey">
<Description>
Canonic (index) name of the cube this query is based on.</Description>
<Type>%DeepSee.Datatype.string</Type>
<Internal>1</Internal>
</Property>

<Property name="%QueryKey">
<Description>
Query key for the current query.</Description>
<Type>%DeepSee.Datatype.string</Type>
<Internal>1</Internal>
</Property>

<Property name="%Statistics">
<Description>
Array of timing and performance statistics for the current query.</Description>
<Type>%DeepSee.Datatype.string</Type>
<MultiDimensional>1</MultiDimensional>
</Property>

<Property name="%UseCache">
<Description>
If true, then use results caching for this query.</Description>
<Type>%Boolean</Type>
<InitialExpression>1</InitialExpression>
</Property>

<Property name="%Recompute">
<Description>
If true recompute previously run queries whose data has been updated
otherwise return old values.</Description>
<Type>%Boolean</Type>
<InitialExpression>1</InitialExpression>
</Property>

<Property name="%AxisCount">
<Description>
Holds the number of axes in the current query.</Description>
<Type>%Integer</Type>
<Internal>1</Internal>
</Property>

<Property name="%NamedParameters">
<Description><![CDATA[
Array of named parameters with current values.
These are set by the <method>%SetParameterContext</method> method.<br/>]]></Description>
<Type>%Integer</Type>
<Internal>1</Internal>
<MultiDimensional>1</MultiDimensional>
</Property>

<Property name="%ListingSQL">
<Description><![CDATA[
This holds the SQL query generated by a DRILLTHROUGH query.
Use the <method>%GetListingSQL</method> to get this.]]></Description>
<Type>%String</Type>
<Private>1</Private>
<Parameter name="MAXLEN" value="32000"/>
</Property>

<Property name="%ListingResult">
<Description><![CDATA[
This holds the SQL StatementResult object created by a DRILLTHROUGH query.
Use the <method>%GetListingResult</method> to get this.]]></Description>
<Type>%SQL.StatementResult</Type>
<Private>1</Private>
</Property>

<Property name="%ListingFields">
<Description><![CDATA[
List of fields to display for a DRILLTHROUGH query.
Use the <method>%GetListingResult</method> to get this.]]></Description>
<Type>%List</Type>
<Private>1</Private>
</Property>

<Property name="listing">
<Description>
If set, this is the name of a listing within the current cube to use for detail listings.</Description>
<Type>%String</Type>
<Parameter name="MAXLEN" value="255"/>
</Property>

<Property name="listingRows">
<Description>
Number of rows in the current listing query.</Description>
<Type>%Integer</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="listingPageSize">
<Description>
Number of rows within a listing query "page".</Description>
<Type>%Integer</Type>
<InitialExpression>1000</InitialExpression>
</Property>

<Property name="listingPage">
<Description>
Current "page" of listing query.</Description>
<Type>%Integer</Type>
<InitialExpression>1</InitialExpression>
</Property>

<Property name="listingFormatList">
<Description>
Formatting string to apply to listing results.</Description>
<Type>%String</Type>
<Parameter name="MAXLEN" value="5000"/>
</Property>

<Method name="%ExecuteDirect">
<Description><![CDATA[
Convience method.<br/>
Creates a result set, prepares the query <var>pMDX</var>, and executes it.<br/>
Returns an instance of the result set.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pMDX:%String,&pParms,*pSC:%Status]]></FormalSpec>
<ReturnType>%DeepSee.ResultSet</ReturnType>
<Implementation><![CDATA[
	Set pSC = $$$OK
	Set tRS = ""
	Try {
		Set tRS = ..%New()
		Set pSC = tRS.%PrepareMDX(pMDX)
		If $$$ISERR(pSC) Quit

		Set pSC = tRS.%Execute(.pParms)
		If $$$ISERR(pSC) Quit
	}
	Catch(ex) {
		Set pSC = ex.AsStatus()
		Set tRS = ""
	}
	Quit tRS
]]></Implementation>
</Method>

<Method name="%PrepareMDX">
<Description><![CDATA[
Given the text of a DeepSee MDX query, <var>pMDX</var>, 
parse it, convert it to a DeepSee run-time query object, and
prepare it so that it can then be executed.<br/>
<var>pVariables</var> is an options list of pivot variable names and their current values.
These are substituted for any pivot variable references within the query before it is parsed.<br/>
<var>pResolvedMDX</var> is the query text after any pivot variable references have been resolved.]]></Description>
<FormalSpec><![CDATA[pMDX:%String,&pVariables,*pResolvedMDX]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set ..%Query = ""
		Set ..%QueryKey = ""
		Set ..%Cube = ""
		Set ..%CubeKey = ""
		Set ..%AxisCount = ""
		Set ..%ListingSQL = ""
		Set ..%ListingResult = ""
		Set ..%ListingFields = ""

		// parse the query
		Set tQuery = ##class(%DeepSee.Query.query).%New()
		Merge tQuery.%NamedParameters = ..%NamedParameters

		// JMD1276: resolve any pivot variables within the query
		// these are basically macro substitutions using the named parameter list as values
		Set tMarker = "$variable."
		Set tMDXLower = $$$LOWER(pMDX)
		If (tMDXLower[tMarker) {
			Set tMDX = ""
			Set p=1,next=1
			While (next>0) {
				Set next = $Find(tMDXLower,tMarker,next)
				If (next=0) {
					Set tMDX = tMDX _ $E(pMDX,p,*)
					Quit
				}
				Else {
					Set tMDX = tMDX _ $E(pMDX,p,next-$L(tMarker)-1)
					Set p = next
					While (($E(pMDX,next)'="")&&($ZNAME("X"_$E(pMDX,next)))) {
						Set next = next+1
					}
					Set tVar = $$$LOWER($E(pMDX,p,next-1))
					If (tVar="") {
						Set tMDX = tMDX _ tMarker
					}
					Else {
						Set tValue = $G(pVariables(tVar))
						Set:tValue="" tValue = """"""
						Set tMDX = tMDX _ tValue
					}
				}
				Set p = next
			}
			Set pMDX = tMDX
		}

		Set pResolvedMDX = pMDX

		Set tSC = ..%ParseMDX(pMDX,tQuery)
		If $$$ISERR(tSC) Quit

		// n.b., this will set %Query
		Set tSC = ..%PrepareObject(tQuery)
		If $$$ISERR(tSC) Quit
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%PrepareObject">
<Description><![CDATA[
Given a DeepSee run-time query, <var>pQuery</var>, 
prepare it so that it can then be executed.]]></Description>
<FormalSpec>pQuery:%DeepSee.Query.query</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set ..%Query = pQuery
		Set ..%QueryKey = ""
		Set ..%Cube = ""
		Set ..%CubeKey = ""
		Set ..%AxisCount = ""
		Set ..%ListingSQL = ""
		Set ..%ListingResult = ""
		Set ..%ListingFields = ""

		Set ..%Query.useCache = ..%UseCache
		Set ..%Query.recompute = ..%Recompute
		If ((pQuery.queryType="CREATE")||(pQuery.queryType="DROP")) {
			Set ..%Cube = ..%Query.cube
			Set ..%CubeKey = $$$DeepSeeIndex(..%Cube)
			Quit
		}

		Set tSC = ..%Query.%Prepare()
		If $$$ISERR(tSC) Quit

		// Note: key is not available until ExecuteParameters is called
		Set ..%QueryKey = ..%Query.%QueryKey
		Set ..%Cube = ..%Query.cube
		Set ..%CubeKey = $$$DeepSeeIndex(..%Cube)
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%PrepareKey">
<Description><![CDATA[
Given a DeepSee query key, <var>pQueryKey</var>, 
(returned by a previous query prepare),
restore the state of the query so that it can
be executed.<br/>]]></Description>
<FormalSpec>pCubeName:%String,pQueryKey:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		If ((pCubeName="")||(pQueryKey="")) {
			Set tSC = $$$ERROR($$$GeneralError,"Missing cube or query key in %PrepareKey")
			Quit
		}

		#; See if this query is in the cache
		Set tCubeIndex = $$$DeepSeeIndex(pCubeName)
		If ('$D($$$DeepSeeResultsGLVN(tCubeIndex,pQueryKey))) {
			Set tSC = $$$ERROR($$$GeneralError,"No query found for key")
			Quit
		}
		Set ..%QueryKey = pQueryKey
		Set ..%Cube = pCubeName
		Set ..%CubeKey = $$$DeepSeeIndex(..%Cube)
		Set ..%Query = ##class(%DeepSee.Query.query).%New()
		Merge ..%Query.%NamedParameters = ..%NamedParameters
		Set ..%Query.cube = pCubeName
		Set ..%Query.%QueryKey = pQueryKey
		Set ..%AxisCount = ""

		#; check status
		Set tStatus = ..%GetQueryStatus(pCubeName,pQueryKey)
		If (tStatus < 30) {
			// JMD1156
			//Set tSC = $$$ERROR($$$GeneralError,"ExecuteAxes must be called before PrepareKey")
			//Quit
		}
		Set ..%Query.queryType = $G($$$DeepSeeResultsGLVN(..%CubeKey,..%QueryKey,"queryType"))
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%SetListing">
<Description>
Specify which listing to use for detail listings.</Description>
<FormalSpec>pListing:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set ..listing = pListing
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%SetParameterContext">
<Description><![CDATA[
Take a pre-defined set of named parameters and apply them to MDX
queries executed against this result set.<br/>
This makes it possible to add defined parameters to a query without 
adding them to the query text. This is different than supplying run-time values
for parameters when executing the query.<br/>
The named parameter context is an array subscripted by UPPER CASE parameter
name and parameter attribute (which can be "VALUE","TYPE",or "CAPTION").<br/>
For example:<br/>
pContext("CITY","VALUE") = "New York"<br/>
Call this before preparing a query.]]></Description>
<FormalSpec><![CDATA[&pContext]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Kill ..%NamedParameters
		Merge ..%NamedParameters = pContext
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%GetQuery">
<Description>
Return the DeepSee run-time query object currently in use
as the source for this result set.</Description>
<ReturnType>%DeepSee.Query.query</ReturnType>
<Implementation><![CDATA[	Quit ..%Query
]]></Implementation>
</Method>

<Method name="%GetQueryKey">
<Description>
Return the current Query Key for this Result Set.
The result set must be prepared before calling this.</Description>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	Quit ..%QueryKey
]]></Implementation>
</Method>

<Method name="%GetCubeName">
<Description>
Return the name of the cube this ResultSet is executing against.
The result set must be prepared before calling this.</Description>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	Quit ..%Cube
]]></Implementation>
</Method>

<Method name="%GetLastDataUpdate">
<Description>
Output the cube last data update date in the XMLA format</Description>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tCubeKey = ..%CubeKey
	Set tLastDataUpdate = $G($$$DeepSeeMetaGLVN("cubes",tCubeKey,"lastDataUpdate"))
	If (tLastDataUpdate'="") {
		// format is: "2009-06-19T15:55:31"
		Set tLastDataUpdate = $TR($ZDT(tLastDataUpdate,3)," ","T")
	}
	Quit tLastDataUpdate
]]></Implementation>
</Method>

<Method name="%GetLastSchemaUpdate">
<Description>
Output the cube last schema update date in the XMLA format</Description>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tCubeKey = ..%CubeKey
	Set tLastSchemaUpdate = $G($$$DeepSeeMetaGLVN("cubes",tCubeKey,"lastSchemaUpdate"))
	If (tLastSchemaUpdate'="") {
		// format is: "2009-06-19T15:55:31"
		Set tLastSchemaUpdate = $TR($ZDT(tLastSchemaUpdate,3)," ","T")
	}
	Quit tLastSchemaUpdate
]]></Implementation>
</Method>

<Method name="%GetListingResultSet">
<Description><![CDATA[
Prepare and execute the listing query for the current MDX statement.
Return an SQL ResultSet that can be used to iterate over the listing.
If <var>pFieldList</var> is not empty, then it is a $List of fields that
should be selected and displayed from the result set.]]></Description>
<FormalSpec>*pRS:%SQL.StatementResult,*pFieldList:%List</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Set pRS = ..%ListingResult
	Set pFieldList = ..%ListingFields
	If (pRS="") {
		Set tSC = $$$ERROR($$$GeneralError,"No listing result available")
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%GetListingSQL">
<Description>
Return the SQL statement needed to drill into the source table for a DRILLTHROUGH statement.
This may return the name of the DataConnector class if that is how the listing is defined.</Description>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	Quit ..%ListingSQL
]]></Implementation>
</Method>

<Method name="%IsDrillThrough">
<Description>
Test if this is a DRILLTHROUGH statement.</Description>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	Set tIsDrill = 0
	If ((..%CubeKey'="")&&(..%QueryKey'="")) {
		Set tIsDrill = $G($$$DeepSeeResultsGLVN(..%CubeKey,..%QueryKey,"queryType")) = "DRILLTHROUGH"
	}
	Quit tIsDrill
]]></Implementation>
</Method>

<Method name="%GetQueryText">
<Description>
Return the text of the query currently associated with this result set.
This text is generated from the query parse tree and represents the canonic form
of the query.</Description>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tText = ""
	If ((..%CubeKey'="")&&(..%QueryKey'="")) {
		Set tText = $G($$$DeepSeeResultsGLVN(..%CubeKey,..%QueryKey,"query",1))
	}
	Quit tText
]]></Implementation>
</Method>

<Method name="%GetQueryStatus">
<Description><![CDATA[
Given a cube name and a query key (as returned by the <method>%ExecuteAsync</method>)
return the current status of the query.<br/>
0 indicates that nothing has been done; 100 indicates that 
query execution is complete and that results are ready; a value
in between means that work is ongoing.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCubeName:%String,pQueryKey:%String,*pPercentComplete:%Double,*pSC:%Status,*pPendingResults:%Boolean</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	// JMD900
	Set pPendingResults = 0

	Set pSC = $$$OK
	Set pPercentComplete = ""
	Quit:pCubeName="" 0
	Quit:pQueryKey="" 0
	Set tCubeIndex = $$$DeepSeeIndex(pCubeName)

	// If query has an error, report it
	Set pSC = $G($$$DeepSeeResultsGLVN(tCubeIndex,pQueryKey,"error"),$$$OK)
	If $$$ISERR(pSC) {
		Set pPercentComplete = 100
		Quit 100
	}

	Set tStatus = $G($$$DeepSeeResultsGLVN(tCubeIndex,pQueryKey,"status"))
	If (tStatus = "") {
		// not ready yet OR someone killed the results global (don't log that!)
		If $D($$$DeepSeeResultsGLVN(tCubeIndex,pQueryKey)) {
			Do ##class(%DeepSee.Utils).%WriteToLog("ResultSet","GetQueryStatus no status found")
		}
		Quit 0
	}
	Set tStatus = +tStatus
	Set tCellTaskGroup = $G($$$DeepSeeResultsGLVN(tCubeIndex,pQueryKey,"cellTaskGroup"))
	Set tAxesTaskGroup = $G($$$DeepSeeResultsGLVN(tCubeIndex,pQueryKey,"axesTaskGroup"))

	// JMD1156
	If ((tStatus < 30)&&(tAxesTaskGroup'="")) {
		If ($G($$$DeepSeeTaskGroupGLVN(tAxesTaskGroup,"errorCode"))'="") {
			// error: stop
			Set tStatus = 100
			Set pPercentComplete = 100
		}
		If '##class(%DeepSee.TaskMaster).%IsActive() {
			Set pSC = $$$ERROR($$$GeneralError,"No background agents available to process query")
			Quit
		}
		
		// find approx total number of items in all axes
		Set tMbrCount = 0
		Set tAxisNo = $O($$$DeepSeeResultsGLVN(tCubeIndex,pQueryKey,"axis",""),1,tAxisKey)
		While (tAxisNo'="") {
			Set tLastKey = $O($$$DeepSeeAxisGLVN(tCubeIndex,tAxisKey,"axes",""),-1)
			Set tMbrCount = tMbrCount + tLastKey
			Set tAxisNo = $O($$$DeepSeeResultsGLVN(tCubeIndex,pQueryKey,"axis",tAxisNo),1,tAxisKey)
		}
		Set pPercentComplete = tMbrCount
	}
	ElseIf (tCellTaskGroup'="") {
		If ($G($$$DeepSeeTaskGroupGLVN(tCellTaskGroup,"errorCode"))'="") {
			// error: stop
			Set tStatus = 100
			Set pPercentComplete = 100
		}

		If '##class(%DeepSee.TaskMaster).%IsActive() {
			Set pSC = $$$ERROR($$$GeneralError,"No background agents available to process query")
			Quit
		}

		Set tCount = +$G($$$DeepSeeTaskGroupGLVN(tCellTaskGroup,"count"))
		Set tComplete = +$G($$$DeepSeeTaskGroupGLVN(tCellTaskGroup,"complete"))
		Set:tCount>0 pPercentComplete = (tComplete/tCount)*100
	}
	ElseIf (tStatus > 50) {
		Set pPercentComplete = 100

		// JMD900: test for pending results
		Set pPendingResults = ''$D($$$DeepSeeResultsGLVN(tCubeIndex,pQueryKey,"pending"))
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="%GetCellCount">
<Description><![CDATA[
Given a cube name and a query key (as returned by the <method>%ExecuteAsync</method>)
return the number of result cells that are returned by the query.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCubeName:%String,pQueryKey:%String,*pSC:%Status</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	Set pSC = $$$OK
	Quit:pCubeName="" 0
	Quit:pQueryKey="" 0
	Set tCubeIndex = $$$DeepSeeIndex(pCubeName)

	// If query has an error, report it
	Set pSC = $G($$$DeepSeeResultsGLVN(tCubeIndex,pQueryKey,"error"),$$$OK)
	Quit +$G($$$DeepSeeResultsGLVN(tCubeIndex,pQueryKey,"cells"))
]]></Implementation>
</Method>

<Method name="%CancelQuery">
<Description>
Cancel the query, if running, specified by the cube name and query key.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCubeName:%String,pQueryKey:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		If ((pCubeName="")||(pCubeName="")) {
			Set tSC = $$$ERROR($$$GeneralError,"Query not specified")
			Quit
		}
		Set tCubeName = $$$UPPER(pCubeName)
		Set tStatus = +$G($$$DeepSeeResultsGLVN(tCubeName,pQueryKey,"status"))
		Set tExecTaskGroup = $G($$$DeepSeeResultsGLVN(tCubeName,pQueryKey,"execTaskGroup"))
		Set tCellTaskGroup = $G($$$DeepSeeResultsGLVN(tCubeName,pQueryKey,"cellTaskGroup"))
		If (tCellTaskGroup'="") {
			Do ##class(%DeepSee.TaskMaster).%KillTasksForGroup(tCellTaskGroup)
			Kill $$$DeepSeeResultsGLVN(tCubeName,pQueryKey)
			Kill $$$DeepSeeTasksGLVN
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%GetStatus">
<Description><![CDATA[
Instance method version of <method>%GetQueryStatus</method>.]]></Description>
<FormalSpec>*pPercentComplete:%Double,*pSC:%Status,*pPendingResults:%Boolean</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	Set pSC = $$$OK
	Set pPendingResults = 0
	If ((..%Query.queryType="CREATE")||(..%Query.queryType="DROP")) {
		Set pPercentComplete = 100
		Quit 100
	}
	Quit ..%GetQueryStatus(..%Cube,..%QueryKey,.pPercentComplete,.pSC,.pPendingResults)
]]></Implementation>
</Method>

<Method name="%GetParameterInfo">
<Description>
Return the set of named parameters values defined by the query.</Description>
<FormalSpec>*pParms</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Kill pParms
		If '$IsObject(..%Query) {
			Set tSC = $$$ERROR($$$GeneralError,"Result set not prepared")
			Quit
		}
		Set tSC = ..%Query.%GetParameterInfo(.pParms)
		If $$$ISERR(tSC) Quit
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%Execute">
<Description><![CDATA[
Execute the current prepared query for this ResultSet.<br/>
If defined, <var>pParms</var> is an array of parameter values
subscripted by parameter name (case-insensitive). These are supplied
to the query and override the default values for any parameters
defined by the query.]]></Description>
<FormalSpec><![CDATA[&pParms]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK

	Try {
		If ((..%Query.queryType = "CREATE")||(..%Query.queryType = "DROP")) {
			Set tSC = ..%ExecuteSessionCommand()
			Quit
		}

		If (..%QueryKey="") {
			// if query key is present, then assume parameters are already executed
			Set tSC = ..%ExecuteParameters(.pParms)
			If $$$ISERR(tSC) Quit
		}

		Set tSC = ..%ExecuteAxes()
		If $$$ISERR(tSC) Quit

		Set tSC = ..%ExecuteCells()
		If $$$ISERR(tSC) Quit
		
		If (..%Query.queryType = "DRILLTHROUGH") {
			Set tSC = ..%ExecuteListing()
			If $$$ISERR(tSC) Quit
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%ExecuteAsynch">
<Description><![CDATA[
Perform a complete execution of the ResultSet using
background agents.<br/>
The query must be prepared before calling this method.<br/>
If defined, <var>pParms</var> is an array of parameter values
subscripted by parameter name (case-insensitive). These are supplied
to the query and override the default values for any parameters
defined by the query.<br/>
If <var>pWait</var> is true, wait for the query to complete execution before
returning.<br/>
If <var>pAxesOnly</var> is true, then only execute the axes for the query.]]></Description>
<FormalSpec><![CDATA[*pQueryKey:%String,&pParms,pWait:%Boolean=0,pAxesOnly:%Boolean=0,pAxesQuery:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK

	Try {
		If '$IsObject(..%Query) {
			Set tSC = $$$ERROR($$$GeneralError,"Result set not prepared")
			Quit
		}

		If (..%QueryKey="") {
			// if query key is present, then assume parameters are already executed
			Set tSC = ..%ExecuteParameters(.pParms)
			If $$$ISERR(tSC) Quit
		}

		If ((..%Query.queryType = "CREATE")||(..%Query.queryType = "DROP")) {
			// do not use async
			Set tSC = ..%ExecuteSessionCommand()
			Quit
		}
		ElseIf (..%Query.queryType = "DRILLTHROUGH") {
			// force wait
			Set tSC = ..%Query.%ExecuteAsynch(1)
			If $$$ISERR(tSC) Quit

			Set tSC = ..%ExecuteListing()
			If $$$ISERR(tSC) Quit
		}
		Else {
			Set tSC = ..%Query.%ExecuteAsynch(pWait,,pAxesOnly,pAxesQuery)
			If $$$ISERR(tSC) Quit
		}
		Set pQueryKey = ..%QueryKey
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%ExecuteParameters">
<Description>
Apply the array of parameter values to the currently prepared query.</Description>
<FormalSpec><![CDATA[&pParms]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	
	Try {
		If '$IsObject(..%Query) {
			Set tSC = $$$ERROR($$$GeneralError,"Result set not prepared")
			Quit
		}
		Set tSC = ..%Query.%ExecuteParameters(.pParms)
		If $$$ISERR(tSC) Quit

		Set ..%QueryKey = ..%Query.%QueryKey
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%ExecuteAxes">
<Description>
Materialize the initial (pre-null-filtered) axes for this ResultSet.</Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	
	Try {
		If '$IsObject(..%Query) {
			Set tSC = $$$ERROR($$$GeneralError,"Result set not prepared")
			Quit
		}
		Set tSC = ..%Query.%ExecuteAxes()
		If $$$ISERR(tSC) Quit
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%ExecuteCells">
<Description>
Calculate the contents of the result cells for this Result Set.</Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		If '$IsObject(..%Query) {
			Set tSC = $$$ERROR($$$GeneralError,"%ExecuteCells: Result set not prepared")
			Quit
		}
		Write:..%Trace "Execute Cells: ",!
		Set tSC = ..%Query.%ExecuteCells(..%Trace)
		If $$$ISERR(tSC) Quit
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%ExecuteListing">
<Description>
For a DRILLTHROUGH query, find the set of source ids that make up
the *first* cell in the results and compute the SQL statement needed
to fetch the request fields from the source table (either as 
specified in the query's RETURN clause or the default listing for the cube).</Description>
<Internal>1</Internal>
<FormalSpec>pStoreFactBits:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tMaxRows = ..%Query.%MaxListingRows
		Set tAxisCount = ..%GetAxisCount()
		Set tCube = $$$UPPER(..%Cube)
		Set tCubeIndex = ..%CubeKey
		Set tQueryKey = ..%QueryKey
		Set tListingTable = ""

		// this works as follows:
		// first we get the set of bits that describe the selected facts
		// then we get the source id for each fact and write it to 
		// the listing global
		// the listing global is mapped to a ListingTable (one per cube)
		// we then JOIN the sourceTable against ListingTable (using SQL with a subquery)
		// to get the listing rows.

		// JMD985: determine which facts are from list levels
		Set tFactCount = 0
		Set fn = $O($$$DeepSeeMetaGLVN("cubes",tCube,"fact#",""),1,tFactName)
		While (fn'="") {
			Set tFactCount = tFactCount+1
			If (tFactName'="") {
				Set tList = +$G($$$DeepSeeMetaGLVN("cubes",tCube,"fact","prop",tFactName,"list"))
				Set:tList tFactIsList(fn)=1
			}
			Set fn = $O($$$DeepSeeMetaGLVN("cubes",tCube,"fact#",fn),1,tFactName)
		}

		// Kill prior listing, if any
		Kill $$$DeepSeeListingGLVN(tCubeIndex,tQueryKey)
		Kill $$$DeepSeeListingBitGLVN(tCubeIndex,tQueryKey)

		Set tSourceType = $G($$$DeepSeeMetaGLVN("cubes",tCube,"sourceType"))
		Set tSourceClass = $G($$$DeepSeeMetaGLVN("cubes",tCube,"sourceClass"))
		If (tSourceClass="") {
			Set tSC = $$$ERROR($$$GeneralError,"%ExecuteListing: cube has no source class: " _ tCube)
			Quit
		}

		Set tCubeClass = $G($$$DeepSeeMetaGLVN("cubes",tCube))
		If ('$zobjclassmethod(tCubeClass,"%CanDrillThrough")) {
			If (..%Query.%listingSource '= "facts") {
				// JMD906: allow DRILLFACTS in this case
				Set tSC = $$$ERROR($$$GeneralError,"%ExecuteListing: this cube does not support drill through: " _ tCube)
				Quit
			}
		}

		Set tFactClass = ##class(%DeepSee.Utils).%GetCubeFactClass(tCube, .tSC)
		If $$$ISERR(tSC) Quit

		Set tSourceTable = ""
		If (..%Query.%listingSource = "facts") {
			Set tSourceTable = ##class(%DeepSee.Utils).%GetSQLTableName(tFactClass)
		}
		Else {
			If (tSourceType = "persistent") {
				Set tSourceTable = ##class(%DeepSee.Utils).%GetSQLTableName(tSourceClass)
				If (tSourceTable="") {
					Set tSC = $$$ERROR($$$GeneralError,"%ExecuteListing: cube has no source table: " _ tCube)
					Quit
				}
			}
		}

		// JMD955: if the slicer filters out everything, then return no values
		Set tNoRecords = 0

		Set tSlicer = $G($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"slicer"))

		// see if slicer has any actual restrictions in it
		If (tSlicer'="") {
			// Get slicer key
			Set tSlicerKey = $G($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"axis",0))
			If (tSlicerKey'="") {
				Do ##class(%DeepSee.Query.Engine).%GetBranchesForSlicer(tCube, tSlicerKey, .tBranch,,.tReferencedFacts)
				If ('$D(tBranch)) {
					Set tSlicer = ""
					// JMD955: Return no records;
					If $D(tReferencedFacts) {
						Set tNoRecords = 1
					}
				}
			}
		}

		// compute "window" from page and page size
		// JMD1318: for first page, get everything-- could be a group by query
		If (..listingPage=1) {
			Set tStartRow = 1
			Set tEndRow = 100000000
			Set tFirstPage = 1
		}
		Else {
			Set tStartRow = ((..listingPage-1) * ..listingPageSize) + 1
			Set tEndRow = tStartRow + ..listingPageSize - 1
			Set tFirstPage = 0
		}

		// AxisCount=0 is a special case: SELECT FROM CUBE
		Set tReturnAll = (tAxisCount = 0)||tNoRecords

		If (('tReturnAll)||(tSlicer'="")) {
			// convert to listing table
			Set tListingClass = $P(tFactClass,".",1,$L(tFactClass,".")-1)_".Listing"
			Set tListingTable = ##class(%DeepSee.Utils).%GetSQLTableName(tListingClass)
			If (tListingTable="") {
				Set tSC = $$$ERROR($$$GeneralError,"%ExecuteListing: cube has no listing table: " _ tCube)
				Quit
			}

			// number of fact properties in cube
			Set tFactCount = +$G($$$DeepSeeMetaGLVN("cubes",tCube,"fact#"))

			// find set of relations for this cube (if any)
			// these will be processed using a join index
			Set r = $O($$$DeepSeeMetaGLVN("cubes",tCube,"rel#",""))
			While (r'="") {
				Set tRelation(r) = ""
				Set r = $O($$$DeepSeeMetaGLVN("cubes",tCube,"rel#",r))
			}

			// get "spec" for set of facts (from cell 1,1)
			// n.b., drillthrough only looks at top left cell
			Set tSpec = $Case(tAxisCount,
				0:..%GetValue(),
				1:..%GetOrdinalValue(1),
				:..%GetOrdinalValue(1,1))

			// JMD836: keys in spec are not in canonic form (e.g. "2|3|4&2")
			// fix them here
			// JMD955: test for bad list (e.g., "No Results")
			If '$ListValid(tSpec) {
				Set tSpec = ""
			}

			For p=1:1:$LL(tSpec) {
				// JMD985: do not canonize list facts
				// remember if there are ORs in the slicer, then tSpec is concatenated
				// for each branch!
				If '$D(tFactIsList((p#(tFactCount+1))-1)) {
					Set xp = $LG(tSpec,p)
					Set:(xp'="")&&($E(xp)'="!") $List(tSpec,p) = ##class(%DeepSee.Query.Engine2).%CanonizeAddr(xp)
				}
			}

			// break spec into pieces (each with one complete set of fact keys)
			// if there are multiple pieces, they are OR'd together
			Set tPieceCount = $LL(tSpec) / (tFactCount+1)
			For p=1:1:tPieceCount {
				Set x = (p-1)*(tFactCount+1)

				// JMD858 Test for empty spec; this means return all rows; (SELECT ALLMBR ON 0...)
				Set tSpec2 = $List(tSpec,x+1,x+tFactCount+1)
				Set tSpecNotEmpty = 0
				For px=1:1:$LL(tSpec2) {
					If ($LG(tSpec2,px)'="") {
						Set tSpecNotEmpty = 1
						Quit
					}
				}
				If (tSpecNotEmpty) {
					Set tSpecPart(p) = tSpec2
				}
				ElseIf (tSlicer'="") {
					// skip this spec
					Set tSpecPart(p) = ""
				}
				Else {
					Set tReturnAll = 1
					Quit
				}
			}

			If (('tReturnAll)||(tSlicer'="")) {
				Set tUseFacts = (..%Query.%listingSource = "facts")

				// loop over fact extent and apply filtering
				Set tCount = 0
				Set tChunk = $O($$$DeepSeeIndexGLVN(tCubeIndex,"$Fact",""),1,data)

				// JMD1318: ignore tMaxRows when fetching bits for first page
				// this makes it possible to run GROUP BY and other queries
				While ((tChunk '= "")&&(tFirstPage||pStoreFactBits||(tCount<tMaxRows))) {

					If ($BitFind(data,1)>0) {
						Kill tFullMask
						For p=1:1:tPieceCount {
							// JMD858: skip missing spec
							If (tSpecPart(p)="") {
								// set spec to extent mask
								Set tFullMask = data
							}
							Else {
								Set tMask = data
								For f = 1:1:tFactCount {
									Set k = $LG(tSpecPart(p),f+1)
									If (k'="") {
										If ($D(tRelation(f))&&($E(k)="@")) { // this is a relation
											// JMD1017
											Set khash = $S($L(k)<100:k,1:$ZCRC(k,7))

											If '$D(tMask) {
												Set tMask = $G($$$DeepSeeJoinGLVN(tCubeIndex,f,khash,tChunk))
											}
											Else {
												Set tMask = $BitLogic(tMask&$$$DeepSeeJoinGLVN(tCubeIndex,f,khash,tChunk))
											}
										}
										Else {
											// JMD1160: loop over & first
											For j = 1:1:$L(k,"&") {
												Set k2 = $P(k,"&",j)
												If (k2'="") {
													Kill tTest
													If (k2["|") {
														// OR
														For j2 = 1:1:$L(k2,"|") {
															Set k3 = $P(k2,"|",j2)
															If (k3'="") {
																Set tTest(j2) = tMask
																If ($E(k3)="!") {
																	// strip off marker and negate index
																	Set k3 = $E(k3,2,*)
																	Set tTest(j2) = $BitLogic(tTest(j2)&~$$$DeepSeeIndexGLVN(tCubeIndex,f,k3,tChunk))
																}
																Else {
																	Set tTest(j2) = $BitLogic(tTest(j2)&$$$DeepSeeIndexGLVN(tCubeIndex,f,k3,tChunk))
																}
															}
														}
														// fold branches
														Set tMask = ""
														Set jx = $O(tTest(""))
														If (jx'="") {
															Set tMask = tTest(jx)
															Set jx = $O(tTest(jx))
														}
														While (jx'="") {
															Set tMask = $BitLogic(tMask|tTest(jx))
															Set jx = $O(tTest(jx))
														}
													}
													Else {
														// test for NOT (!)
														If ($E(k2)="!") {
															// strip off marker and negate index
															Set k2 = $E(k2,2,*)
															Set tMask = $BitLogic(tMask&~$$$DeepSeeIndexGLVN(tCubeIndex,f,k2,tChunk))
														}
														Else {
															Set tMask = $BitLogic(tMask&$$$DeepSeeIndexGLVN(tCubeIndex,f,k2,tChunk))
														}
													}
												}
											}
										}
									}
									Set:$D(tMask)&($BitCount(tMask,1)=0) tMask=""
								} // f

								// OR pieces together
								If ('$D(tFullMask)&&$D(tMask)) {
									Set tFullMask = $G(tMask)
								}
								ElseIf ($D(tFullMask)&&$D(tMask)) {
									Set tFullMask = $BitLogic(tFullMask|tMask)
								}
							} // for p
						} // spec'=""


						// mask against extent
						If $D(tFullMask) {
							// JMD858: make tFullMask the lvar
							// (already masked)
							// Set tFullMask = $BitLogic(data&tFullMask)
						
							// BDB243: store bitset output
							Set:pStoreFactBits $$$DeepSeeListingBitGLVN(tCubeIndex, tQueryKey, tChunk) = tFullMask
						}

						// emit ids
						Set tOffset = (tChunk-1)*64000
						Set tBit = $BitFind(tFullMask,1)
						While ((tBit > 0)&&(tFirstPage||(tCount<tMaxRows))) {
							Set tFactId = tBit+tOffset-1
							If (tUseFacts) {
								// JMD906: no need to convert ids
								Set tCount = tCount + 1
								If ((tCount>=tStartRow)&&(tCount<=tEndRow)) {
									Set $$$DeepSeeListingGLVN(tCubeIndex,tQueryKey,tFactId) = ""
								}
							}
							Else {
								// convert into sourceId via %sourceId reverse index
								Set tSourceId =  $G($$$DeepSeeIndexGLVN(tCubeIndex,"%sourceIdReverse",tFactId))

								If (tSourceId'="") {
									Set tCount = tCount + 1
									If ((tCount>=tStartRow)&&(tCount<=tEndRow)) {
										// insert directly into listing table the old-fashioned way!
										Set $$$DeepSeeListingGLVN(tCubeIndex,tQueryKey,tSourceId) = ""
									}
								}
							}
							Set tBit = $BitFind(tFullMask,1,tBit+1)
						}
					}
					Set tChunk = $O($$$DeepSeeIndexGLVN(tCubeIndex,"$Fact",tChunk),1,data)
				} // next chunk
			} // return All
		} // axis count

		// BDB251: make sure $$$DeepSeeListingBitGLVN is populated if tReturnAll=1 && tSlicer=""
		If (tReturnAll && (tSlicer="") && pStoreFactBits && 'tNoRecords) {
			// this is not particularly fast for large datasets, but the bitstring is
			// at least 100% correct and the code only gets executed if pStoreFactBits
			// was explicitly set to 1 by the invoking code
			set tFactId="", tPrevChunk=0, tBits=""
			for {
				set tFactId = $order($$$DeepSeeIndexGLVN(tCubeIndex,"%sourceIdReverse",tFactId))
				quit:tFactId=""
				
				set tChunk = (tFactId\64000)+1, tBitPos = (tFactId#64000)+1
				if (tChunk '= tPrevChunk) {
					set:tPrevChunk $$$DeepSeeListingBitGLVN(tCubeIndex, tQueryKey, tPrevChunk) = tBits, tBits=""
					set tPrevChunk = tChunk
				}
				set $bit(tBits,tBitPos)=1
			}
			set:tPrevChunk $$$DeepSeeListingBitGLVN(tCubeIndex, tQueryKey, tPrevChunk) = tBits
		}

		Set ..listingRows = $G(tCount,tMaxRows)
		Set:..listingRows>tMaxRows ..listingRows = tMaxRows		// JMD1318

		// ----------------------------------------------
		// now create query

		// tListingSourceClass is set if the cube defines a data connector for its listing
		Set tListingSourceClass = ""
		Set tCustomSQL = ""
		Set tSelectList = ""
		Set ..listingFormatList = ""

		// figure out what SQL or connector to use
		// $LISTING means use default in place
		Set ..%ListingFields = ""
		Set tSourceRowId = "%ID"

		// JMD1061 Use %GetDefaultListing method
		Set tListing = ..listing
		If (tListing="") {
			Set tListing = $classmethod(tCubeClass,"%GetDefaultListing")
		}

		If ((..%Query.%returnList '= "")&&($ZSTRIP($$$UPPER(..%Query.%returnList),"<>W")'="$LISTING")) {
			// explicit listing in query
			Set tSelectList = ..%Query.%returnList
		}
		ElseIf (..%Query.%listingSource = "facts") {
			// query against fact table (not source table)
			Set tSelectList = "%ID"
		}
		ElseIf (tListing'="") {
			// use named listing in cube
			// test if user holds resource for this listing
			Set tResource = $G($$$DeepSeeMetaGLVN("cubes",tCube,"listing",tListing,"resource"))
			If ((tResource="")||($System.Security.Check(tResource,"USE"))) {
				Set tSelectList = $G($$$DeepSeeMetaGLVN("cubes",tCube,"listing",tListing,"fieldList"),tSourceRowId)
				Set tCustomSQL = $G($$$DeepSeeMetaGLVN("cubes",tCube,"listing",tListing,"sql"))
				Set tListingSourceClass = $G($$$DeepSeeMetaGLVN("cubes",tCube,"listing",tListing,"sourceClass"))
				Set ..listingFormatList = $G($$$DeepSeeMetaGLVN("cubes",tCube,"listing",tListing,"formatList"))
			}
			Else {
				Set tSC = $$$ERROR($$$GeneralError,"Listing does not exist or you do not hold USE permission for it")
				Quit
			}
		}
		Else {
			// get default for cube
			Set tResource = $G($$$DeepSeeMetaGLVN("cubes",tCube,"defaultListingResource"))
			If ((tResource="")||($System.Security.Check(tResource,"USE"))) {
				Set tSelectList = $G($$$DeepSeeMetaGLVN("cubes",tCube,"defaultListing"),tSourceRowId)
				Set tCustomSQL = $G($$$DeepSeeMetaGLVN("cubes",tCube,"defaultListingSQL"))
				Set tListingSourceClass = $G($$$DeepSeeMetaGLVN("cubes",tCube,"defaultListingSourceClass"))
				Set ..listingFormatList = $G($$$DeepSeeMetaGLVN("cubes",tCube,"defaultListingFormat"))
			}
			Else {
				Set tSC = $$$ERROR($$$GeneralError,"Listing does not exist or you do not hold USE permission for it")
				Quit
			}
		}

		// if true, restrict listing using an IN clause otherwise use a local subquery
		Set tUseINList = 0

		// use primary data connector for listing if none specified
		If (tListingSourceClass="") {
			Set tSourceType = $G($$$DeepSeeMetaGLVN("cubes",tCube,"sourceType"))
			If (tSourceType="dataconnector") {
				Set tListingSourceClass = $G($$$DeepSeeMetaGLVN("cubes",tCube,"sourceClass"))
			}
		}

		If (tListingSourceClass '= "") {
			// data connector
			Set tSupportsIDs=($$$defMemberKeyGet(tListingSourceClass,$$$cCLASSparameter,"SUPPORTSIDLIST",$$$cPARAMdefault)'="")
			If ('tSupportsIDs) {
				Set tSC = $$$ERROR($$$GeneralError,"Data Connector does not support listings")
				Quit
			}

			Set ..%ListingSQL = "{" _ tListingSourceClass _ "}"
			/* JMD1309: there appears to be no need to create a list of fields:
						we can get it from the result set meta data
			If (tSelectList'="") {
				For p2=1:1:$L(tSelectList,",") {
					Set tFld = $ZSTRIP($P(tSelectList,",",p2),"<>W")
					Set:tFld'="" ..%ListingFields = ..%ListingFields_$LB(tFld)
				}
			}
			*/
		}
		ElseIf (tCustomSQL = "") {
			Set tExternalTable=($$$defMemberKeyGet(tSourceClass,$$$cCLASSparameter,"CONNECTION",$$$cPARAMdefault)'="")
			If (tExternalTable) {
				Set tUseINList = 1
				Set tMaxRows = 1000
				// there is a hard limit on external listings
				// to avoid xDBC query problems
			}
			// create SQL query
			// add names to the select list
			// add qualifier to names in select list
			// unless name is already qualified
			Set tSELECT = ""
			For n=1:1:$L(tSelectList,",") {
				Set f = $ZSTRIP($P(tSelectList,",",n),"<>W")
				Set:f'="" tSELECT = tSELECT _ $S(tSELECT="":"",1:",") _ $S(($E(f,1)="("):f,$IsValidNum(+f):f,($$$UPPER(f))["SOURCE.":f,1:"source."_f)
			}

			Set tORDER = ""
			If (..%Query.%returnList '= "") {
				Set tOrderList = ..%Query.%orderList
			}
			ElseIf (..%Query.%listingSource = "facts") {
				Set tOrderList = ..%Query.%orderList
			}
			ElseIf (..listing'="") {
				// use named listing in cube
				Set tOrderList = $G($$$DeepSeeMetaGLVN("cubes",tCube,"listing",..listing,"orderBy"))
			}
			Else {
				Set tOrderList = $G($$$DeepSeeMetaGLVN("cubes",tCube,"defaultListingOrder"))
			}

			// add names to order list
			// qualify names if needed
			Set tORDER = ""
			For n=1:1:$L(tOrderList,",") {
				Set f = $ZSTRIP($P(tOrderList,",",n),"<>W")
				Set:f'="" tORDER = tORDER _ $S(tORDER="":"",1:",") _ $S(($E(f,1)="("):f,$IsValidNum(+f):f,($$$UPPER(f))["SOURCE.":f,1:"source."_f)
			}
			Set:tORDER'="" tORDER = " ORDER BY " _ tORDER

			Set tWHERE = ""
			Set tFROM = tSourceTable_" source"
			If (('tReturnAll)||(tSlicer'="")) {
				If (tUseINList) {
					Set tIDCount = 0
					Set tDone = 0

					Set tINLIST = ""
					Set k = $O($$$DeepSeeListingGLVN(tCubeIndex,tQueryKey,""))
					While (k'="") {
						Set tIDCount = tIDCount + 1
						Set tINLIST = tINLIST _ $S(tINLIST="":"",1:",") _ "("_$Replace($$$quote(k),"""","'")_")"
						If (tIDCount>=tMaxRows) {
							Quit
						}
						Set k = $O($$$DeepSeeListingGLVN(tCubeIndex,tQueryKey,k))
					}
					If (tINLIST'="") {
						Set tWHERE = " WHERE source."_tSourceRowId_" IN ("_tINLIST_") "
					}
					Else {
						// no records
						Set tWHERE = " WHERE 1=0"
					}
				}
				Else {
					Set tWHERE = " WHERE source."_tSourceRowId_" IN (SELECT _DSsourceId FROM " _ tListingTable _ " WHERE _DSqueryKey = '"_tQueryKey_"')"
				}
			}
			If (tWHERE = "") {
				// special case of returning ALL source rows
				// see if there is a loadRestriction in play
				Set tRestrict = $G($$$DeepSeeMetaGLVN("cubes",tCubeIndex,"buildRestriction"))
				If (tRestrict'="") {
					// JMD942
					If (..%Query.%listingSource '= "facts") {
						Set tWHERE = " WHERE " _ tRestrict
					}
				}
			}

			Set tTOP = ""
			If ('tExternalTable) {
				Set tTOP = "TOP "_+tMaxRows_" "
			}
			
			// JMD1127 replace $$$TEXT[ in SELECT
			//set tSC = ..RewriteQueryTag(.tSELECT, "$$$TEXT", "##class(%DeepSee.UserPortal.Utils).%ResolveText(""$$$""_$tr(""$$$1"",""""""'"")_""/""_$tr(""$$$2"",""""""'""))",,,, 1)
			//quit:$$$ISERR(tSC)
			Set tIKPos = $Find(tSELECT, "$$$TEXT[")
			While (tIKPos) {
				Set tParams = $E(tSELECT, tIKPos, $Find(tSELECT, "]", tIKPos)-2)
				Set tString = $Translate($Piece(tParams,",",1), """'")
				Set tDomain = $Translate($Piece(tParams,",",2), """'")
				If (tDomain'="") {
					Set tString = tString_"/"_tDomain
				}
				Set tString =  ##class(%DeepSee.UserPortal.Utils).%ResolveText("$$$"_tString)
				Set tSELECT = $E(tSELECT,1,tIKPos-9) _ tString _ $E(tSELECT,tIKPos+$length(tParams)+1,*)
				Set tIKPos = $Find(tSELECT, "$$$TEXT[")
			}
			
			// BDB383: replace $$$PMML model references ($$$PMML[defClass,modelname,feature])
			set tSC = ..RewriteQueryTag(.tSELECT, "$$$PMML", "%DeepSee_PMML_Utils.DeepSee_RunModelForListing('"_tCube_"', source.%ID, '$$$1', '$$$2', '$$$3')", $lb(,,"predictedValue"))
			quit:$$$ISERR(tSC)

			// BDB168: support for iKnow summaries (BDB238: more than 1 per query)
			set tSC = ..RewriteQueryTag(.tSELECT, "$$$IKSUMMARY", "%iKnow_DeepSee.CubeUtils_GetSummary('"_tCube_"', '$$$1', source.%ID, $$$2)", $lb(,5), "$$$1 (summary)")
			quit:$$$ISERR(tSC)
			
			// BDB296: support for iKnow measure value popup
			set tSC = ..RewriteQueryTag(.tSELECT, "$$$IKLINK", "'''"_tCube_"'',''$$$1'','||source.%ID",, "$$$1", "___IKLINK")
			quit:$$$ISERR(tSC)
			
			// JMD955
			If (tNoRecords) {
				Set tWHERE = " WHERE (1=0) "
			}

			Set ..%ListingSQL = "SELECT "_tTOP_tSELECT_" FROM "_tFROM_tWHERE_tORDER
		}
		Else {
			// custom sql statement
			Set tWHERE = ""
			Set tFROM = tSourceTable_" source"

			If (('tReturnAll)||(tSlicer'="")) {
				If (tUseINList) {
					// in this case, impose a hard limit on the size of the IN list!
					Set tINLIST = ""

					Set k = $O($$$DeepSeeListingGLVN(tCubeIndex,tQueryKey,""))
					While (k'="") {
						Set tINLIST = tINLIST _ $S(tINLIST="":"",1:",") _ $Replace($$$quote(k),"""","'")
						Set k = $O($$$DeepSeeListingGLVN(tCubeIndex,tQueryKey,k))
					}

					If (tINLIST'="") {
						Set tWHERE = " source."_tSourceRowId_" IN ("_tINLIST_") "
					}
				}
				Else {
					Set tWHERE = " source."_tSourceRowId_" IN (SELECT _DSsourceId FROM " _ tListingTable _ " WHERE _DSqueryKey = '"_tQueryKey_"') "
				}
			}
			Else {
				Set tWHERE = " (1=1) "
			}

			Set tCustomSQL = $Replace(tCustomSQL,"$$$SOURCE",tFROM)
			Set tCustomSQL = $Replace(tCustomSQL,"$$$RESTRICT",tWHERE)
			
			// JMD1127: replace $$$TEXT[] parameters for listings
			//set tSC = ..RewriteQueryTag(.tCustomSQL, "$$$TEXT", "##class(%DeepSee.UserPortal.Utils).%ResolveText(""$$$""_$tr(""$$$1"",""""""'"")_""/""_$tr(""$$$2"",""""""'""))",,,, 1)
			//quit:$$$ISERR(tSC)
			Set tIKPos = $Find(tCustomSQL, "$$$TEXT[")
			While (tIKPos) {
				Set tParams = $E(tCustomSQL, tIKPos, $Find(tCustomSQL, "]", tIKPos)-2)
				Set tString = $Translate($Piece(tParams,",",1), """'")
				Set tDomain = $Translate($Piece(tParams,",",2), """'")
				If (tDomain'="") {
					Set tString = tString_"/"_tDomain
				}
				Set tString =  ##class(%DeepSee.UserPortal.Utils).%ResolveText("$$$"_tString)
				Set tCustomSQL = $E(tCustomSQL,1,tIKPos-9) _ tString _ $E(tCustomSQL,tIKPos+$length(tParams)+1,*)
				Set tIKPos = $Find(tCustomSQL, "$$$TEXT[")
			}
			
			// BDB383: replace $$$PMML model references ($$$PMML[defClass,modelname,feature])
			set tSC = ..RewriteQueryTag(.tCustomSQL, "$$$PMML", "%DeepSee_PMML_Utils.DeepSee_RunModelForListing('"_tCube_"', source.%ID, '$$$1', '$$$2', '$$$3')", $lb(,,"predictedValue"))
			quit:$$$ISERR(tSC)
			
			// BDB168: replacing parameters for iKnow Listings (BDB238: more than 1 per query)
			set tSC = ..RewriteQueryTag(.tCustomSQL, "$$$IKSUMMARY", "%iKnow_DeepSee.CubeUtils_GetSummary('"_tCube_"', '$$$1', source.%ID, $$$2)", $lb(,5), "$$$1 (summary)")
			quit:$$$ISERR(tSC)
			
			// BDB296: support for iKnow measure value popup
			set tSC = ..RewriteQueryTag(.tCustomSQL, "$$$IKLINK", "'''"_tCube_"'',''$$$1'','||source.%ID",, "$$$1", "___IKLINK")
			quit:$$$ISERR(tSC)
			
			Set ..%ListingSQL = tCustomSQL
		}

		// prepare result set
		If (tListingSourceClass '= "") {
			Set tConnector = $zobjclassmethod(tListingSourceClass,"%New")
			If ('tConnector.%IsA("%DeepSee.DataConnector")) {
				Set tSC = $$$ERROR($$$GeneralError,"Source class is not a DataConnector: " _ tListingSourceClass)
				Quit
			}

			// pass restriction information to connector
			If (tListingTable'="") {
				Set tSC = tConnector.%SetMode("idlist")
				If $$$ISERR(tSC) Quit

				Set tSC = tConnector.%SetIdList(tListingTable,tQueryKey,tCubeIndex)
				If $$$ISERR(tSC) Quit
			}

			// Run dataconnector in odbc-mode
			Set dcm = $ZU(115,5,1)

			Kill tParms
			Set ..%ListingResult = tConnector.%Execute(.tParms,.tSC)
			Set x = $ZU(115,5,dcm)
			If $$$ISERR(tSC) Quit
		}
		Else {
			// sql

			// invoke callback
			Set tCubeClass = $G($$$DeepSeeMetaGLVN("cubes",tCube))
			Set tSC = $zobjclassmethod(tCubeClass,"%OnExecuteListing",..%ListingSQL)
			If $$$ISERR(tSC) Quit
		
			// prepare listing query
			Set tStatement = ##class(%SQL.Statement).%New(,"DEFAULT_SCHEMA")
			Set tStatement.%SelectMode = 1 // odbc-mode

			Set tSC = tStatement.%Prepare(..%ListingSQL)
			If $$$ISERR(tSC) {
				// log this error
			    Set tMsg = "Error in Listing query:"
			    Set tMsg = tMsg _ $C(13,10,9)_ ..%ListingSQL
			    Set tMsg = tMsg _ $C(13,10,9)_ $System.Status.GetErrorText(tSC)
			    Do ##class(%DeepSee.Utils).%WriteToLog("Listing",tMsg)
				Quit
			}
			Set ..%ListingResult = tStatement.%Execute()
		}
		Set $$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"plan",$I($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"plan"))) = $LB("listing",tCube,..%ListingSQL)
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="RewriteQueryTag">
<Description><![CDATA[
Replaces a "tag" in a listing query <var>pSQL</var> (fieldList or straight SQL), using the 
string in <var>pRewrite</var>. The tag (such as $$$IKSUMMARY) can have zero or more parameters
in square brackets, which will be used to replace $$$1, $$$2, etc markers in <var>pRewrite</var>,
defaulting to the corresponding positions in <var>pDefaultParams</var> if no value is supplied
with the tag. <var>pRewrite</var> is supposed to contain appropriate quotes, as surrounding
single and double quotes in the tag itself will be removed.
If <var>pDefaultAlias</var> is non-null, it will be appended as the column alias for the rewrite
expression. This alias can also contain $$$1, $$$2, etc markers.
If <var>pAliasPrefix</var> is set, it will be prepended to any existing (or default) alias.
If <var>pStatic</var>=1, the rewrite code is considered to be COS code and run once, with its
result then replacing the tag in the query.]]></Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pSQL:%String,pTagName:%String,pRewrite:%String,pDefaultParams:%List="",pDefaultAlias:%String="",pAliasPrefix:%String="",pStatic:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		set tTagLength = $length(pTagName)
		set tParamCount = $length(pRewrite_" "_pDefaultAlias,"$$$")-1
		
		while 1 {
			// find the next occurrence of pTagName
			set tPos = $find(pSQL, pTagName)
			quit:'tPos
			set tSqlLength = $length(pSQL), tStartPos = tPos-tTagLength-1
			
			// locate closing "]" and parameter list
			kill tParams
			set tParams = 0
			if ($e(pSQL,tPos)="[") {
				set tQuotes = "", tLastParamStart = tPos+1
				while ($i(tPos)<=tSqlLength) {
					set tChar = $e(pSQL,tPos)
					
					if (tChar=tQuotes) {
						if $e(pSQL,tPos+1)=tQuotes {
							// double quote!
							set tPos = tPos+1
							continue
						} else {
							// end of a quoted string
							set tQuotes = ""
							continue
						}
					} elseif (tChar="""") || (tChar="'") {
						// start of a quoted string
						set tQuotes = tChar
						continue
					}
					
					// skip if we're in a quoted string
					continue:tQuotes'=""
					
					// parameter ends at "]" or ","
					if (tChar = "]") || (tChar=",") {
						
						// get rid of surrounding quotes, these should be taken care of by pRewrite
						set tParam = $zstrip($e(pSQL,tLastParamStart,tPos-1),"<>W")
						if ($e(tParam)="'") && ($e(tParam,*)="'") {
							set tParam = $e(tParam,2,*-1)
						} elseif ($e(tParam)="""") && ($e(tParam,*)="""") {
							set tParam = $e(tParam,2,*-1)
						}
						set tParams($i(tParams)) = tParam
						
						quit:(tChar="]")
						set tLastParamStart = tPos+1
					}
					
				}
				set tEndPos = tPos+1
			} else {
				set tEndPos = tPos
			}
			
			// alias processing
			if (pDefaultAlias'="") || (pAliasPrefix'="") {
				if ($e(pSQL,tPos)=",") {
					// no trailing space, parameters or alias
					set tAlias = ""
				} else {
					set tQuotes = "", tAliasStart = tPos+1
					while ($i(tPos)<=tSqlLength) {
						set tChar = $e(pSQL,tPos)
						
						if (tChar=tQuotes) {
							if $e(pSQL,tPos+1)=tQuotes {
								// double quote!
								set tPos = tPos+1
								continue
							} else {
								// end of a quoted string
								set tQuotes = ""
								continue
							}
						} elseif (tChar="""") {
							// start of a quoted string
							set tQuotes = tChar
							continue
						}
						
						// skip if we're in a quoted string
						continue:tQuotes'=""
						
						quit:tChar=","
						quit:$e(pSQL,tPos,tPos+4)="FROM "
					}
					set tAliasEnd = tPos-1
					
					set tAlias = $zstrip($e(pSQL, tAliasStart, tAliasEnd), "<>W")
					
					// get rid of "As" keyword
					set:$$$UPPER($e(tAlias,1,3))="AS " tAlias = $zstrip($e(tAlias,4,*), "<>W")
					
					// get rid of alias quotes. we'll restore them later if required
					set:($e(tAlias)="""")&&($e(tAlias,*)="""") tAlias = $zstrip($e(tAlias,2,*-1), "<>W")
					
					set tEndPos = tAliasEnd+1
				}
				
				if (tAlias="") {
					set tAlias = pDefaultAlias
				}
				
				if (pAliasPrefix'="") {
					set tAlias = pAliasPrefix_$s(tAlias="":"", 1:" "_tAlias)
				}
				
				set:$f(tAlias," ") tAlias = $$$QUOTE(tAlias)
				set:tAlias'="" tAlias = " As "_tAlias
			} else {
				set tAlias = ""
			}
			
			set tRewrite = pRewrite
			set:tParams>tParamCount tParamCount = tParams
			for i = 1:1:tParamCount {
				set tParam = $g(tParams(i),$lg($g(pDefaultParams),i))
				set tRewrite = $replace(tRewrite, "$$$"_i, tParam)
				set tAlias = $replace(tAlias, "$$$"_i, tParam)
			}
			
			if (pStatic) {
				xecute ("(tValue) { set tValue = "_tRewrite_" }", .tValue)
				set tRewrite = tValue
			}
			
			set pSQL = $e(pSQL,1,tStartPos) _ " "_tRewrite_tAlias_" " _ $e(pSQL,tEndPos,*)
		}
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="%ExecuteSessionCommand">
<Description>
Perform the work of a CREATE or DROP statement.</Description>
<Internal>1</Internal>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		If (..%Query.queryType = "CREATE") {
			// apply definition
			If (..%Query.%target = "set") {
				Set tKey = ""
				Set tSet = ..%Query.namedSets.GetNext(.tKey)
				While (tKey '= "") {
					// add definition to session data
					If $IsObject($G($$$DeepSeeSession)) {
						Set tSessionId = $$$DeepSeeSession.%GetSessionId()
						Set tInfo = $LB(tSet.name,tSet.definition)
						Set $$$DeepSeeSessionGLVN(tSessionId,..%CubeKey,"namedSets",tKey) = tInfo
					}
					Set tSet = ..%Query.namedSets.GetNext(.tKey)
				}
			}
			ElseIf (..%Query.%target = "member") {
				Set tKey = ""
				Set tSet = ..%Query.calculatedMembers.GetNext(.tKey)
				While (tKey '= "") {
					// add definition to session data
					If $IsObject($G($$$DeepSeeSession)) {
						Set tSessionId = $$$DeepSeeSession.%GetSessionId()
						Set tInfo = $LB(tSet.parentDimension,tSet.originalName,tSet.definition)
						Set $$$DeepSeeSessionGLVN(tSessionId,..%CubeKey,"calcMbrs",tKey) = tInfo
					}
					Set tSet = ..%Query.calculatedMembers.GetNext(.tKey)
				}
			}
		}
		ElseIf (..%Query.queryType = "DROP") {
			If (..%Query.%target = "set") {
				Set tKey = ..%Query.%targetKey
				If (tKey '= "") {
					// remove definition from session data
					If $IsObject($G($$$DeepSeeSession)) {
						Set tSessionId = $$$DeepSeeSession.%GetSessionId()
						Kill $$$DeepSeeSessionGLVN(tSessionId,..%CubeKey,"namedSets",tKey)
					}
				}
			}
			ElseIf (..%Query.%target = "member") {
				Set tKey = ..%Query.%targetKey
				If (tKey '= "") {
					// remove definition from session data
					If $IsObject($G($$$DeepSeeSession)) {
						Set tSessionId = $$$DeepSeeSession.%GetSessionId()
						Kill $$$DeepSeeSessionGLVN(tSessionId,..%CubeKey,"calcMbrs",tKey)
					}
				}
			}
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%GetAxisSize">
<Description>
Return number of visible nodes within the given axis (1-based).</Description>
<FormalSpec>pAxis:%Integer</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[	Quit +$G($$$DeepSeeResultsGLVN(..%CubeKey,..%QueryKey,"leaf",pAxis))
]]></Implementation>
</Method>

<Method name="%GetAxisCount">
<Description><![CDATA[
Return number of axes within the result set (not including the slicer).
Returns 0 if the query has not been prepared and had its
axes executed.<br/>
On return, <var>pInfo</var> will contain array of axis number (1-based)
to axis top node number.]]></Description>
<FormalSpec>*pInfo:%Integer</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	Kill pInfo
	Set tCount = 0
	Set tCube = ..%CubeKey
	Set tKey = ..%QueryKey

	If ((tCube'="")&&(tKey'="")&&($D($$$DeepSeeResultsGLVN(tCube,tKey,"size"),size))) {
		For n = 1:1:$LL(size) {
			Set tInfo = $LG(size,n)
			Set tType = $LG(tInfo,1)
			If (tType = "axis") {
				Set tCount = tCount + 1
				Set pInfo(tCount) = $LG(tInfo,2)
			}
		}
	}
	
	Set ..%AxisCount = tCount
	Quit tCount
]]></Implementation>
</Method>

<Method name="%HasCellFormatOverride">
<Description>
Return true if the current query has to be tested for cell format overrides.</Description>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[	Quit ''$D($$$DeepSeeResultsGLVN(..%CubeKey,..%QueryKey,"cmbrMap"))
]]></Implementation>
</Method>

<Method name="%GetCellFormatOverride">
<Description><![CDATA[
Determine if the format for the given cell has been overridden (such as by
currentMember substitution) and return it.
<var>pCell...</var> contains the ordinal address of the cell.]]></Description>
<FormalSpec>pCell...</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tFormat = ""
	Set tAxisCount = ..%AxisCount
	If (tAxisCount="") {
		Set tAxisCount = ..%GetAxisCount()
	}
	Set tCube = ..%CubeKey
	Set tMissing = 0

	For a = 1:1:tAxisCount {
		// If no cell specified, use first cell along axis
		Set tCell = $S($G(pCell(a))'="":pCell(a),1:$O($$$DeepSeeResultsGLVN(tCube,..%QueryKey,"leaf",a,"")))

		If (tCell'="") {
			// find node number for cell
			Set tNode(a) = $G($$$DeepSeeResultsGLVN(tCube,..%QueryKey,"leaf",a,tCell))
		}

		If ((tCell="") || (tNode(a)="")) {
			Set tMissing = 1
			Quit
		}
	}

	If ('tMissing) {
		Set tFormat = $LG($G($$$DeepSeeResultsGLVN(tCube,..%QueryKey,"cmbrMap",tNode(1),tNode(2),0)),12)
	}
	Quit tFormat
]]></Implementation>
</Method>

<Method name="%GetOrdinalValue">
<Description><![CDATA[
Get the value of the cell specified by the ordinal cell numbers 
<var>pCell1</var>, <var>pCell2</var>...<br/>
A cell number is the ordinal number of a cell along its axis.<br/>
The column axis is axis number 1, the row axis is axis number 2 and so on.<br/>
If the result has more dimensions than are provided, or if values are omitted, then the
first cell along each additional dimension is used.]]></Description>
<FormalSpec>pCell...</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tAxisCount = ..%AxisCount
	If (tAxisCount="") {
		Set tAxisCount = ..%GetAxisCount()
	}
	Set tCube = ..%CubeKey
	Set tValue = ""
	Set tMissing = 0

	For a = 1:1:tAxisCount {
		// If no cell specified, use first cell along axis
		Set tCell = $S($G(pCell(a))'="":pCell(a),1:$O($$$DeepSeeResultsGLVN(tCube,..%QueryKey,"leaf",a,"")))

		If (tCell'="") {
			// find node number for cell
			Set tNode(a) = $G($$$DeepSeeResultsGLVN(tCube,..%QueryKey,"leaf",a,tCell))
		}

		If ((tCell="") || (tNode(a)="")) {
			Set tMissing = 1
			Quit
		}
	}

	If ('tMissing) {
		Set tValue = $Case(tAxisCount,
			0:..%GetValue(),
			1:..%GetValue(tNode(1)),
			2:..%GetValue(tNode(1),tNode(2)),
			3:..%GetValue(tNode(1),tNode(2),tNode(3)),
			4:..%GetValue(tNode(1),tNode(2),tNode(3),tNode(4)),
			5:..%GetValue(tNode(1),tNode(2),tNode(3),tNode(4),tNode(5)),
			6:..%GetValue(tNode(1),tNode(2),tNode(3),tNode(4),tNode(5),tNode(6)),
			7:..%GetValue(tNode(1),tNode(2),tNode(3),tNode(4),tNode(5),tNode(6),tNode(7)),
			:"")
	}

	Quit tValue
]]></Implementation>
</Method>

<Method name="%GetValue">
<Description><![CDATA[
Get the value of the cell specified by the node numbers 
<var>pNode1</var>, <var>pNode2</var>...]]></Description>
<FormalSpec>pNode...</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	// count nodes
	Set tCount = 0
	Set n = $O(pNode(""))
	While (n'="") {
		Set tCount = tCount + 1
		Set n = $O(pNode(n))
	}
	Set tValue = $Case(tCount,
		0:$G($$$DeepSeeResultsGLVN(..%CubeKey,..%QueryKey,"data",0)),
		1:$G($$$DeepSeeResultsGLVN(..%CubeKey,..%QueryKey,"data",0,pNode(1))),
		2:$G($$$DeepSeeResultsGLVN(..%CubeKey,..%QueryKey,"data",0,pNode(1),pNode(2))),
		3:$G($$$DeepSeeResultsGLVN(..%CubeKey,..%QueryKey,"data",0,pNode(1),pNode(2),pNode(3))),
		4:$G($$$DeepSeeResultsGLVN(..%CubeKey,..%QueryKey,"data",0,pNode(1),pNode(2),pNode(3),pNode(4))),
		5:$G($$$DeepSeeResultsGLVN(..%CubeKey,..%QueryKey,"data",0,pNode(1),pNode(2),pNode(3),pNode(4),pNode(5))),
		6:$G($$$DeepSeeResultsGLVN(..%CubeKey,..%QueryKey,"data",0,pNode(1),pNode(2),pNode(3),pNode(4),pNode(5),pNode(6))),
		7:$G($$$DeepSeeResultsGLVN(..%CubeKey,..%QueryKey,"data",0,pNode(1),pNode(2),pNode(3),pNode(4),pNode(5),pNode(6),pNode(7))),
		:"")
	Quit tValue
]]></Implementation>
</Method>

<Method name="%GetOrdinalLabel">
<Description><![CDATA[
Find the axis label(s) for the item with ordinal position
<var>pPosition</var> within axis <var>pAxis</var> (1 = cols, 2 = rows).<br/>
Returns, via <var>pLabel</var> an array of labels associated with the item
from the most specific to the most general.<br/>
The return value is the number of labels returned.<br/>
Also returns, by reference the format and solve order for the label (higher solve order
takes precedence over lower and is used to determine which axis should supply the format for
a cell).]]></Description>
<FormalSpec>*pLabel:%String,pAxis:%Integer,pPosition:%Integer,*pFormat:%String,*pSolveOrder:%Integer,*pStyle:%String,*pHeaderStyle:%String</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	Kill pLabel
	Set pFormat = ""
	Set pStyle = ""
	Set pHeaderStyle = ""
	Set pSolveOrder = 0
	Set tLabelCount = 0
	Set tCubeIndex = ..%CubeKey
	Set tAxisKey = $G($$$DeepSeeResultsGLVN(tCubeIndex,..%QueryKey,"axis",pAxis))
	Set tNodeNo = $G($$$DeepSeeResultsGLVN(tCubeIndex,..%QueryKey,"leaf",pAxis,pPosition))
	While (tNodeNo'="") {
		Set tNode = $G($$$DeepSeeAxisGLVN(tCubeIndex,tAxisKey,"axes",tNodeNo))
		Set tType = $LG(tNode,1)
		Set tParent = $LG(tNode,4)
		Set tLabel = $LG(tNode,5)
		Set tSolveOrder = +$LG(tNode,15)
		If (tType = "axis") {
			Quit
		}

		// JMD909
		Set tFormat = $LG(tNode,12)
		Set:tFormat'="" pFormat = tFormat

		Set:tSolveOrder>0 pSolveOrder = tSolveOrder
		If (tLabel'="") {
			Set tLabelCount = tLabelCount + 1
			Set pLabel(tLabelCount) = $LG(tNode,5)
			Set tStyle = $LG(tNode,18)
			Set:tStyle'="" pStyle = tStyle
			Set tHeaderStyle = $LG(tNode,19)
			Set:tHeaderStyle'="" pHeaderStyle = tHeaderStyle
		}
		Set tNodeNo = tParent
	}
	Quit tLabelCount
]]></Implementation>
</Method>

<Method name="%GetRowTotal">
<Description><![CDATA[
Get the total associated with the given row (1-based).<br/>]]></Description>
<FormalSpec>pRow:%Integer,pAgg:%String="sum"</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set:pAgg="" pAgg="sum"
	Quit $G($$$DeepSeeResultsGLVN(..%CubeKey,..%QueryKey,"total",2,pRow,pAgg))
]]></Implementation>
</Method>

<Method name="%GetColumnTotal">
<Description><![CDATA[
Get the total associated with the given column (1-based).<br/>]]></Description>
<FormalSpec>pColumn:%Integer,pAgg:%String="sum"</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set:pAgg="" pAgg="sum"
	Quit $G($$$DeepSeeResultsGLVN(..%CubeKey,..%QueryKey,"total",1,pColumn,pAgg))
]]></Implementation>
</Method>

<Method name="%GetGrandTotal">
<Description><![CDATA[
Get the grand total for the current query.<br/>
This is a simple sum of all cells and not an "aggregate".]]></Description>
<FormalSpec>pAgg:%String="sum"</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	Quit $G($$$DeepSeeResultsGLVN(..%CubeKey,..%QueryKey,"total"))
]]></Implementation>
</Method>

<Method name="%GetPlan">
<Description><![CDATA[
Utility method.<br/>
Assemble the query plan for this query.
The query must have been successfully executed.]]></Description>
<FormalSpec>*pPlan</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Kill pPlan
		Set tStatus = ..%GetQueryStatus(..%Cube,..%QueryKey)
		If (tStatus < 100) {
			Set tSC = $$$ERROR($$$GeneralError,"Query must be executed before its plan can be displayed.")
			Quit
		}
		Set tSC = ..%GetPlanForQuery(.pPlan,..%Cube,..%QueryKey)
		If $$$ISERR(tSC) Quit
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%GetPlanForQuery">
<Description>
Show plan details for the given query.
Do not call this directly.</Description>
<Internal>1</Internal>
<FormalSpec><![CDATA[&pPlan,pCubeName:%String,pQueryKey:%String,pLevel:%Integer=0]]></FormalSpec>
<Private>1</Private>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tCubeIndex = $$$DeepSeeIndex(pCubeName)
		// query text
		Set tText = $G($$$DeepSeeResultsGLVN(tCubeIndex,pQueryKey,"query",1))

		Set tParent = $I(pPlan)
		Set pPlan(tParent) = $LB($S(pLevel>0:"subquery",1:"query"),tText)

		// get plan for this query
		Set tKey = $O($$$DeepSeeResultsGLVN(tCubeIndex,pQueryKey,"plan",""))
		While (tKey '= "") {
			Set tInfo = $$$DeepSeeResultsGLVN(tCubeIndex,pQueryKey,"plan",tKey)
			Set tStep = $LG(tInfo,1)
			Set tCube = $LG(tInfo,2)
			Set tParm = $LG(tInfo,3)
			Set tParm2 = $LG(tInfo,4)
			If (tStep = "sq") { // subquery
				Set tNodeNo = pPlan + 1
				If ((tParm'="")&&(tCube'="")) {
					Set tSC = ..%GetPlanForQuery(.pPlan,tCube,tParm,pLevel+1)
					If $$$ISERR(tSC) Quit
				}
				Set pPlan(tParent,"ch",tNodeNo) = tCube_":"_tParm
			}
			ElseIf (tStep = "dim") {
				Set pPlan($I(pPlan)) = $LB("dim",tParm,tParm2)
				Set pPlan(tParent,"ch",pPlan) = ""
			}
			ElseIf (tStep = "exec") {
				Set pPlan($I(pPlan)) = $LB("exec",tParm,tParm2)
				Set pPlan(tParent,"ch",pPlan) = ""
			}
			ElseIf (tStep = "execA") {
				Set pPlan($I(pPlan)) = $LB("execA",tParm,tParm2)
				Set pPlan(tParent,"ch",pPlan) = ""
			}
			ElseIf (tStep = "cons") {
				Set pPlan($I(pPlan)) = $LB("consolidate")
				Set pPlan(tParent,"ch",pPlan) = ""
			}
			ElseIf (tStep = "listing") {
				Set pPlan($I(pPlan)) = $LB("listing",tParm)
				Set pPlan(tParent,"ch",pPlan) = ""
			}
			Set tKey = $O($$$DeepSeeResultsGLVN(tCubeIndex,pQueryKey,"plan",tKey))
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%ShowPlan">
<Description><![CDATA[
Utility method.<br/>
Print out the plan for this query to the console.
The query must have been successfully executed.]]></Description>
<Implementation><![CDATA[
	Set tStatus = ..%GetQueryStatus(..%Cube,..%QueryKey)
	If (tStatus < 100) {
		Write "Query must be executed before its plan can be displayed.",!
		Quit
	}
	Do ..%ShowPlanForQuery(..%Cube,..%QueryKey)
]]></Implementation>
</Method>

<Method name="%ShowPlanForQuery">
<Description>
Show plan details for the given query.</Description>
<Internal>1</Internal>
<FormalSpec>pCubeName:%String,pQueryKey:%String,pLevel:%Integer=0</FormalSpec>
<Private>1</Private>
<Implementation><![CDATA[
	If ((pCubeName="")||(pQueryKey="")) {
		Quit
	}
	Set tCubeIndex = $$$DeepSeeIndex(pCubeName)

	// query text
	Set tIndent = (pLevel*3)
	Set tText = $G($$$DeepSeeResultsGLVN(tCubeIndex,pQueryKey,"query",1))
	Write ?tIndent,"-------------- ","Query Plan"," ---------------------",!
	Write ?tIndent,"**",tText,"**",!

	// show plan for this query
	Set tKey = $O($$$DeepSeeResultsGLVN(tCubeIndex,pQueryKey,"plan",""))
	While (tKey '= "") {
		Set tInfo = $$$DeepSeeResultsGLVN(tCubeIndex,pQueryKey,"plan",tKey)
		Set tStep = $LG(tInfo,1)
		Set tCube = $LG(tInfo,2)
		Set tParm = $LG(tInfo,3)
		Set tParm2 = $LG(tInfo,4)
		If (tStep = "sq") {
			Write ?tIndent,"**SUBQUERY**",!
			If ((tParm'="")&&(tCube'="")) {
				Do ..%ShowPlanForQuery(tCube,tParm,pLevel+1)
			}
			Else {
				Write ?tIndent,"No query info",!
			}
		}
		ElseIf (tStep = "dim") {
			Write ?tIndent,"**DIMENSION QUERY (",tParm2,"): ",tParm,"**",!
		}
		ElseIf (tStep = "exec") {
			Write ?tIndent,"**EXECUTE: ",tParm,"x",tParm2," task(s) **",!
		}
		ElseIf (tStep = "execA") {
			Write ?tIndent,"**EXECUTE PARALLEL: ",tParm,"x",tParm2," task(s) **",!
		}
		ElseIf (tStep = "cons") {
			Write ?tIndent,"**CONSOLIDATE**",!
		}
		ElseIf (tStep = "listing") {
			Write ?tIndent,"**LISTING QUERY:",tParm," **",!
		}
	
		Set tKey = $O($$$DeepSeeResultsGLVN(tCubeIndex,pQueryKey,"plan",tKey))
	}
	Write ?tIndent,"-------------- ","End of Plan"," -----------------",!
]]></Implementation>
</Method>

<Method name="%Print">
<Description><![CDATA[
Utility method.
Print the results of the current query to the console.<br/>
If <var>pShowNodeNo</var> is true, show the internal node numbers.<br/>
If <var>pMaxRows</var> is defined, limit the number of rows displayed.<br/>]]></Description>
<FormalSpec>*pStats,pShowNodeNo:%Boolean=0,pMaxRows:%Integer=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		If ((..%Query.queryType = "CREATE")||(..%Query.queryType = "DROP")) {
			Quit
		}

		// wait a small time in case a background has not yet reported a error
		Hang 0.01

		Set pMaxRows = $S(pMaxRows>10:pMaxRows-10,1:0)

		Set tError = $G($$$DeepSeeResultsGLVN(..%CubeKey,..%QueryKey,"error"))
		If (tError'="") {
			Set tSC = tError
		}

		If $$$ISERR(tSC) {
			Do $System.Status.DisplayError(tSC)
			W !
			Set tSC = $$$OK
			Quit
		}

		Set tStatus = ..%GetQueryStatus(..%Cube,..%QueryKey)
		If (tStatus < 100) {
			Write $$$Text("Result has errors or is not ready to be printed. Status: ","%DeepSee"),tStatus,!
			Quit
		}
		Set tAxisCount = ..%GetAxisCount()
		Set tShowNodeNums = pShowNodeNo

		If (..%Query.queryType = "DRILLTHROUGH") {
			Do ..%PrintListing()
			If (..%Query.showPlan) {
				Do ..%ShowPlan()
			}
			Quit
		}

		If (tAxisCount = 0) {
			// single value answer
			Set tValue = ..%GetValue()
			Set tCellWidth = 20
			Write $$$Text("Result","%DeepSee"),":",$J($S(tValue="":"*",tValue'=+tValue:tValue,1:$FN(tValue,",")),tCellWidth),!
			If (..%Query.showPlan) {
				Do ..%ShowPlan()
			}
			Quit
		}

		For a = 1:1:tAxisCount {
			Set tAxisSize(a) = ..%GetAxisSize(a)
		}

		Set tVolume = ..%GetCellCount(..%CubeKey,..%QueryKey,.tSC)
		If $$$ISERR(tSC) {
			Do $System.Status.DisplayError(tSC)
			Quit
		}

		// test for default format
		Set tDefFormat = $G($$$DeepSeeResultsGLVN(..%CubeKey,..%QueryKey,"format"))

		// Get row and column info
		Set tStart = $ZH
		Set tColCount = +$G(tAxisSize(1))

		If ((tVolume = 0)||(tColCount=0)) {
			Write $$$Text("ResultSet has found no results","%DeepSee"),!
			// Write "Volume: ",tVolume,?20,"Columns: ",tColCount,!
			If (..%Query.showPlan) {
				Do ..%ShowPlan()
			}
			Quit
		}

		// column headers
		For c=1:1:$G(tAxisSize(1)) {
			Set tLabelCount = ..%GetOrdinalLabel(.tNames,1,c,.tFormat,.tSolveOrder)
			Set tName = $G(tNames(1))
			Set:tFormat'="" tColFormat(c) = tFormat
			Set:tSolveOrder>0 tColSolveOrder(c) = tSolveOrder
			If (tShowNodeNums) {
				Set tColNodes(c) = $G($$$DeepSeeResultsGLVN(..%CubeKey,..%QueryKey,"leaf",1,c))
			}
			Set tColNames(c) = tName
		}

		Set tHasRows = 1
		Set tRowCount = +$G(tAxisSize(2))
		If (tRowCount < 1) {
			Set tHasRows = 0
			Set tRowCount = 1
		}

		Set tLblWidth = 18
		Set tTotal = 0
		Set tCells = 0
		Set tEmptyCells = 0

		Set tHasOverride = ..%HasCellFormatOverride()

		// print
		Set tDisplayedColCount = tColCount
		Set tTruncated = 0
		If (tDisplayedColCount > 6) {
			Set tDisplayedColCount = 6
			Set tTruncated = 1
		}
		If (tDisplayedColCount = 1) {
			Set tLblWidth = 24
		}
		Set tCellWidth = (80 \ (tDisplayedColCount + 1)) - 4
		Set:tCellWidth>18 tCellWidth = 18 
		For c = 1:1:tDisplayedColCount {
			Set tName = $E(tColNames(c),1,tCellWidth-$S(tShowNodeNums:4,1:0)) _ $S(tShowNodeNums:"["_tColNodes(c)_"]",1:"")
			Write ?(c-1)*(tCellWidth+3)+tLblWidth,$J(tName,tCellWidth)
		}
		Write:tTruncated ?76,"..."
		Write !

		// how many digits are needed for row #
		Set tRowDigits = 0
		If (tRowCount>1) {
			Set tRowDigits = (1+$ZLOG(tRowCount))\1
			Set tLblWidth = tLblWidth - tRowDigits
		}

		Set tRowsSkipped = 0
		For r = 1:1:tRowCount {
			Set tRowSolveOrder = 0
			If (tHasRows) {
				Set tName = ""
				Set tLabelCount = ..%GetOrdinalLabel(.tLabels,2,r,.tRowFormat,.tRowSolveOrder)
				For n=tLabelCount:-1:1 {
					Set tName = tName _ $S(tName="":"",1:"->")_ tLabels(n)
				}
			}
			Else {
				Set tName = $$$Text("Results","%DeepSee")
			}
			Set tCells = tCells + tColCount
			If (pMaxRows>0) {
				If ((r > pMaxRows)&&('tRowsSkipped)) {
					Write ".......","rows not displayed",".......",!
					Set tRowsSkipped = 1
					Continue
				}
				ElseIf ((r > pMaxRows)&&(r < (tRowCount-10))) {
					// show last 10 rows
					Continue
				}
			}

			Set tName = $E(tName,1,$S(tShowNodeNums:tLblWidth-4,1:tLblWidth))
			If (tShowNodeNums) {
				Set tName = tName _ "[" _ $G($$$DeepSeeResultsGLVN(..%CubeKey,..%QueryKey,"leaf",2,r)) _ "]"
			}
			// Show row # as well
			Write:tRowDigits>0 $J(r,tRowDigits)," "
			Write tName
			For c = 1:1:tDisplayedColCount {
				Set tValue = $Case(tAxisCount,
					1:..%GetOrdinalValue(c),
					:..%GetOrdinalValue(c,r))

				If (+$G(tColSolveOrder(c))>=+tRowSolveOrder) {
					Set tFormat = $S($G(tColFormat(c))'="":tColFormat(c),$G(tRowFormat)'="":tRowFormat,1:tDefFormat)
				}
				Else {
					Set tFormat = $S($G(tRowFormat)'="":tRowFormat,$G(tColFormat(c))'="":tColFormat(c),1:tDefFormat)
				}

				// JMD988 Test for format override
				If ((tAxisCount>1) && tHasOverride) {
					Set tFO = ..%GetCellFormatOverride(c,r)
					Set:tFO'="" tFormat = tFO
				}

				Set tTotal = tTotal + tValue
				Set:tValue="" tEmptyCells = tEmptyCells + 1

				If (tFormat'="") {
					Write ?(c-1)*(tCellWidth+3)+tLblWidth+tRowDigits+1,$J($S(tValue="":"*",tValue'=+tValue:tValue,1:..%FormatNumber(tValue,tFormat)),tCellWidth)
				}
				Else {
					Write ?(c-1)*(tCellWidth+3)+tLblWidth+tRowDigits+1,$J($S(tValue="":"*",tValue'=+tValue:tValue,tValue'=(tValue\1):$FN(tValue,",",2),1:$FN(tValue,",")),tCellWidth)
				}
			}
			Write:tTruncated ?76,"..."
			Write !
		}

		Set pStats("cells") = tCells
		Set pStats("empty") = tEmptyCells
		Set pStats("total") = tTotal
		Set ..%Statistics("Cells") = tCells
		Set ..%Statistics("Print") = $ZH - tStart

		If (..%Query.showPlan) {
			Do ..%ShowPlan()
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	If $$$ISERR(tSC) {
		Do $System.Status.DisplayError(tSC)
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%PrintListing">
<Description><![CDATA[
Utility method.<br/>
For a DRILLTHROUGH query, print out the listing.]]></Description>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tSC = ..%GetListingResultSet(.tRS,.tListingFields)
		If $$$ISERR(tSC) Quit
		Set tColumnMeta = tRS.%GetMetaData().columns
		If (tListingFields="") {		
			Set tColCount = tColumnMeta.Count()
		}
		Else {
			Set tColCount = $LL(tListingFields)
		}
	
		Write "   #"
		Set tColWidth = $S(tColCount<5:15,tColCount<6:12,tColCount<7:11,tColCount<8:10,1:5)

		If (tListingFields="") {		
			For c = 1:1:tColCount {
				Set tColInfo = tColumnMeta.GetAt(c)
				Write ?(((c-1)*tColWidth)+6),$E(tColInfo.colName,1,tColWidth-1)
			}
		}
		Else {
			For c = 1:1:tColCount {
				Write ?(((c-1)*tColWidth)+6),$E($LG(tListingFields,c),1,tColWidth-1)
			}
		}
		Write !

		Set n = 0
		While (tRS.%Next(.tSC)) {
			If $$$ISERR(tSC) Quit
			Set n = n + 1
			Write $J(n,4),":"
			For c=1:1:tColCount {
				If (tListingFields="") {
					Set tValue = tRS.%GetData(c)
				}
				Else {
					Set tValue = tRS.%Get($LG(tListingFields,c))
				}
				Write ?(((c-1)*tColWidth)+6),$E(tValue,1,tColWidth-1)
			}
			Write !
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	If $$$ISERR(tSC) {
		Do $System.Status.DisplayError(tSC)
		Write !
	}
]]></Implementation>
</Method>

<Method name="%ParseMDX">
<Description><![CDATA[
Lower-level function that, given the text of a DeepSee MDX query, <var>pMDX</var>, 
parses it and converts it to a DeepSee run-time query object without changing
the state of this Result Set.]]></Description>
<FormalSpec>pMDX:%String,pQuery:%DeepSee.Query.query</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		// parse the query
		Set tStart = $ZH
		Set tSC = ##class(%DeepSee.Query.Parser).%ParseMDX(pMDX,pQuery,..%Trace)
		Set ..%Statistics("ParseMDX") = $ZH - tStart
		If $$$ISERR(tSC) Quit

		// JMD1140: test for %LISTING
		If (pQuery.%listing'="") {
			Set ..listing = pQuery.%listing
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%GetAxisMembers">
<Description><![CDATA[
Get information on the members of a specific axis within the current query.<br/>
<var>pAxis</var> is the axis number (1 = cols, 2 = rows, etc.), 0 indicates that
information for the slicer axis is to be returned.<br/>
Because it is impossible to pre-determine the size of a specific axis, the process
private global, <b>^||DeepSee.AxisMembers</b>.
The caller is responsible for killing this global.<br/>
On return, <var>pKey</var> contains the top-level subscript for the process private global
under which the member information is stored.<br/>
The member information takes the form:<br/>
^||DeepSee.AxisMembers(pKey,pAxis,j,k) = $LB(nodeno,text,dimName,hierName,levelName,memberKey,dimNo,hierNo,levelNo,[aggregate])<br/>
pKey is the key returned by this method.<br/>
pAxis is the axis number.<br/>
j is the ordinal position of the tuple within the axis.<br/>
k is the ordinal position of the member within the tuple. k is 0 for members that form a stand-alone tuple.
Otherwise k starts at 0 and increase towards the end of the tuple.<br/>
nodeno is the internal node number corresponding to the member within its axis.<br/>
text is the axis caption for the member.<br/>
Names are not enclosed within [ ] delimiters.<br/>
A fully-qualified name (UNAME) can be constructed by combining the names with the key:<br/>
Set tUName = "["_tDimName_"].["_tHierName_"].["_tLevelName_"].&["_tMemberKey_"]"<br/>
If <var>pItemNo</var> is provided, then it is the ordinal number of a single member within
the axis and only information about this member is returned.<br/>]]></Description>
<FormalSpec>pAxis:%Integer,*pKey,pItemNo:%Integer=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		If '$IsObject(..%Query) {
			Set tSC = $$$ERROR($$$GeneralError,"Result set not prepared")
			Quit
		}
		Set pKey = ..%QueryKey
		If (pKey = "") {
			Set tSC = $$$ERROR($$$GeneralError,"Query key is missing")
			Quit
		}

		Set tIsSlicer = 0
		Set tAxisKey = ""
		If (+pAxis > 0) {
			Set tCount = ..%GetAxisCount(.tAxisInfo)
			Set tAxisKey = $G(tAxisInfo(+pAxis))
		}
		ElseIf (+pAxis=0) {
			// slicer: special case
			Set tIsSlicer = 1
			Set tAxisKey = $G($$$DeepSeeResultsGLVN(..%CubeKey,pKey,"axis",0))
		}

		// add cube name to key
		Set pKey = ..%CubeKey_":"_pKey

		If (tAxisKey="") {
			Quit
		}
		Else {
			Kill ^||DeepSee.AxisMembers(pKey,pAxis)
			Set n = 0
			Set tCube = $$$UPPER(..%Cube)
			Set tCubeIndex = ..%CubeKey

			Set tAxisKey = $G($$$DeepSeeResultsGLVN(tCubeIndex,..%QueryKey,"axis",pAxis))

			// walk down leaf list for this axis
			// n.b., we shouldn't use "all": it may not be in the right order
			// (but there is no evidence of that!)

			Set tInfo = ""
			If (tIsSlicer) {
				Set tNodeNo = $O($$$DeepSeeAxisGLVN(tCubeIndex,tAxisKey,"axes",1,"all",""))
			}
			Else {
				Set tLeafNo = $O($$$DeepSeeResultsGLVN(tCubeIndex,..%QueryKey,"leaf",pAxis,""),1,tNodeNo)
				Set:tLeafNo="" tNodeNo = ""
			}
			While (tNodeNo '= "") {
				Set n = n + 1
				If ((pItemNo="")||(pItemNo=n)) {
					Set tNode = $G($$$DeepSeeAxisGLVN(tCubeIndex,tAxisKey,"axes",tNodeNo))
					Set tType = $LG(tNode,1)
					Set tParent = $LG(tNode,4)
					Set tText = $LG(tNode,5)
					Set tKey = $Case(tType,"mbr":$LG(tNode,13),:"")
					Set tRSpec = $LG(tNode,14)

					If (tType="agg") {
						// this is an aggregate: construct the set of its children
						Set tAgg = $LG(tNode,6)

						// $LB(nodeno,label,dimname,hiername,levelname,memberKey,rSpec)
						// for agg, dimname="" and hiername is agg name
						Set k = 0
						Set tSpec = $LB(+tNodeNo,tText,"",tAgg)
						Set ^||DeepSee.AxisMembers(pKey,pAxis,n,k) = tSpec

						// loop over children
						Set k2 = 0
						Set cn = $O($$$DeepSeeAxisGLVN(tCubeIndex,tAxisKey,"axes",tNodeNo,"ch",""))
						While (cn'="") {
							Set k2 = k2 + 1
							Set tNode2 = $G($$$DeepSeeAxisGLVN(tCubeIndex,tAxisKey,"axes",cn))
							Set tType2 = $LG(tNode2,1)
							Set tParent2 = $LG(tNode2,4)
							Set tText2 = $LG(tNode2,5)
							Set tKey2 = $Case(tType2,"mbr":$LG(tNode2,13),:"")

							// Find dimension name (if we have already seen this, don't bother)
							Set tDimNo2 = +$LG(tNode2,9)
							Set tHierNo2 = +$LG(tNode2,10)
							Set tLevelNo2 = +$LG(tNode2,11)
							If ('$D(tDimInfo(tDimNo2,tHierNo2,tLevelNo2),tInfo2)) {
								Set tInfo2 = $G($$$DeepSeeMetaGLVN("cubes",tCube,"mbr#",tDimNo2,tHierNo2,tLevelNo2))
								Set tDimInfo(tDimNo2,tHierNo2,tLevelNo2) = tInfo2
							}
							Set tDimName2 = $LG(tInfo2,2)
							Set tHierName2 = $LG(tInfo2,3)
							Set tLevelName2 = $LG(tInfo2,4)
							Set tSpec2 = $LB(+tNodeNo,tText2,tDimName2,tHierName2,tLevelName2,tKey2,tDimNo2,tHierNo2,tLevelNo2)
							Set ^||DeepSee.AxisMembers(pKey,pAxis,n,k,k2) = tSpec2

							Set cn = $O($$$DeepSeeAxisGLVN(tCubeIndex,tAxisKey,"axes",tNodeNo,"ch",cn))
						}
					}
					Else {
						// Find dimension name (if we have already seen this, don't bother)
						Set tDimNo = +$LG(tNode,9)
						Set tHierNo = +$LG(tNode,10)
						Set tLevelNo = +$LG(tNode,11)
						If ('$D(tDimInfo(tDimNo,tHierNo,tLevelNo),tInfo)) {
							Set tInfo = $G($$$DeepSeeMetaGLVN("cubes",tCube,"mbr#",tDimNo,tHierNo,tLevelNo))
							Set tDimInfo(tDimNo,tHierNo,tLevelNo) = tInfo
						}
						Set tDimName = $LG(tInfo,2)
						Set tHierName = $LG(tInfo,3)
						Set tLevelName = $LG(tInfo,4)

						// $LB(nodeno,label,dimname,hiername,levelname,memberKey,dno,hno,lno,[rspec])
						Set tSpec = $LB(+tNodeNo,tText,tDimName,tHierName,tLevelName,tKey,tDimNo,tHierNo,tLevelNo,tRSpec)

						Set k = 0				
						While (tParent'="") {
							// get info for parents of this node, if applicable
							Set tParentNode = $G($$$DeepSeeAxisGLVN(tCubeIndex,tAxisKey,"axes",tParent))
							Set tParentType = $LG(tParentNode,1)
							If ((tParentType="axis")) Quit
							If ((tParentType="mbr")||(tParentType="msr")) {
								Set tText = $LG(tParentNode,5)
								Set tKey = $LG(tParentNode,13)
								// Find dimension name (if we have already seen this, don't bother)
								Set tDimNo = +$LG(tParentNode,9)
								Set tHierNo = +$LG(tParentNode,10)
								Set tLevelNo = +$LG(tParentNode,11)
								If ('$D(tDimInfo(tDimNo,tHierNo,tLevelNo),tInfo)) {
									Set tInfo = $G($$$DeepSeeMetaGLVN("cubes",tCube,"mbr#",tDimNo,tHierNo,tLevelNo))
									Set tDimInfo(tDimNo,tHierNo,tLevelNo) = tInfo
								}
								Set tDimName = $LG(tInfo,2)
								Set tHierName = $LG(tInfo,3)
								Set tLevelName = $LG(tInfo,4)
								// Look at parent node, not info
								Set tParentSpec = $LB(+tParent,tText,tDimName,tHierName,tLevelName,tKey,tDimNo,tHierNo,tLevelNo,$LG(tParentNode,14))
								Set ^||DeepSee.AxisMembers(pKey,pAxis,n,k) = tParentSpec
								Set k = k + 1
							}
							Set tParent = $LG(tParentNode,4)
						}
						Set ^||DeepSee.AxisMembers(pKey,pAxis,n,k) = tSpec
					}
				}
				If (tIsSlicer) {
					Set tNodeNo = $O($$$DeepSeeAxisGLVN(tCubeIndex,tAxisKey,"axes",1,"all",tNodeNo))
				}
				Else {
					Set tLeafNo = $O($$$DeepSeeResultsGLVN(tCubeIndex,..%QueryKey,"leaf",pAxis,tLeafNo),1,tNodeNo)
					Set:tLeafNo="" tNodeNo = ""
				}
			}
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%ClearStatistics">
<Description>
Clear out current statistics for this result set.</Description>
<Implementation><![CDATA[	Kill ..%Statistics
]]></Implementation>
</Method>

<Method name="%PrintStatistics">
<Description>
Write out current statistics for this result set.</Description>
<Implementation><![CDATA[
	If ($IsObject(..%Query)) {
		Do ..%Query.%PrintStatistics()
	}

	Write !
	Write "ResultSet Statistics:",!
	Write " Cells:",?25,$$FormatNum($G(..%Statistics("Cells"))),!
	Write " Parse:",?25,$$FormatMS($G(..%Statistics("ParseMDX"))),!
	Write " Display:",?25,$$FormatMS($G(..%Statistics("Print"))),!
	Write " Total Time:",?25,$$FormatMS($G(..%Statistics("ParseMDX"))+$G(..%Statistics("Print"))),!
	Quit

	Set (t,n) = ""
FormatMS(t)
	Quit $J($FN(t*1000,",",3),15)_" ms"

FormatNum(n)
	Quit $J($FN(n,",",0),15)
]]></Implementation>
</Method>

<Method name="%FormatNumber">
<Description><![CDATA[
Apply MDX FORMAT_STRING <var>pFormat</var> to numeric value <var>pValue</var>.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pValue:%Decimal,pFormat:%String,*pType:%String,*pStyle:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tOutput = ""
	Set pStyle = ""

	// there may be a style spec tacked on after a ^
	Set tStyleSpec = $P(pFormat,"^",2)
	Set pFormat = $P(pFormat,"^",1)

	// special case for dates
	If ((pFormat = "yyyy-mm-dd")||(pFormat = "%date%")) {
		Set pStyle = $P(tStyleSpec,";",1)_";"
		Set pType = "date"
		If (+pValue<=0) Quit ""
		If (pFormat = "%date%") {
			Quit $ZDT(pValue\1,,,,,,,,,,"@err")
		}
		Else {
			Quit $ZDT(pValue\1,3,,,,,,,,,"@err")
		}
	}

	Set tFormat = ""
	// JMD988: test for numeric string or special "%string%" format
	// JMD1001: Skip pValue=""
	If ((pValue'="")&&('$IsValidNum(pValue)||(pValue'=+pValue)||(pFormat="%string%"))) {
		Set pType = "string"
		Set pStyle = $P(tStyleSpec,";",1)_";"
		Quit pValue
	}
	Else {
		Set pType = $S(pValue=(pValue\1):"integer",1:"number")
		If (pValue > 0) { // positive
			Set tFormat = $P(pFormat,";",1)
			Set pStyle = $P(tStyleSpec,";",1)
		}
		ElseIf (pValue < 0) {  // negative
			Set tFormat = $P(pFormat,";",2)
			Set:tFormat'="" pValue = pValue * -1
			Set pStyle = $P(tStyleSpec,";",2)
		}
		ElseIf (pValue = 0) {  // zero
			Set tFormat = $P(pFormat,";",3)
			Set pStyle = $P(tStyleSpec,";",3)
		}
		ElseIf (pValue = "") { // missing
			Set tFormat = $P(pFormat,";",4)
			Set pStyle = $P(tStyleSpec,";",4)
			// JMD1001 (2)
			If (tFormat="") {
				Quit ""
			}
		}
	}

	If (pStyle="") {
		Set pStyle = $P(tStyleSpec,";",1)
	}
	If (pStyle'="") {
		Set pStyle = pStyle _ ";"
	}	
	
	Set:tFormat="" tFormat = $P(pFormat,";",1)
	If (tFormat="") {
		// default numeric format
		If (pValue>=0) {
			Quit $FN(pValue,",",$S(pType="integer":0,1:2))
		}
		Else {
			Quit "("_$FN(-pValue,",",$S(pType="integer":0,1:2))_")"
		}
	}

	// apply format
	Set tHasPerCent = tFormat["%"
	Set tHasComma = tFormat[","
	Set tHasZero = tFormat["0"
	Set tHasHash = (tFormat["#")||tHasZero

	Set:tHasPerCent pValue = pValue*100

	// JMD909 - Leading 0s
	Set tLeading0s = 0
	If (tHasZero) {
		// find leading zeroes
		Set t = 1
		While (t<=$L(tFormat)) {
			Set ch = $E(tFormat,t)
			If ((ch="#")||(ch=0)) {
				Set tLeading0s = tLeading0s + 1
			}
			ElseIf ((ch=".")) {
				Quit
			}
			Set t = t + 1
		}
		// now treat 0 as #
		Set tFormat = $Replace(tFormat,"0","#")
	}

	Set tPre = $TR($P(tFormat,"#",1),"\","")
	Set tPost = $S(tHasHash:$TR($P(tFormat,"#",$L(tFormat,"#")),"\",""),1:"")
	Set tScale = 0
	Set d = $F(tFormat,".")
	While (($E(tFormat,d)="#")||($E(tFormat,d)="0")) {
		Set tScale = tScale + 1
		Set d = d + 1
	}

	Set tOutput = $S(tHasHash:$FN(pValue,$S(tHasComma:",",1:""),tScale),1:"")
	Set:tHasZero tOutput = $TR($J($P(tOutput,".",1),tLeading0s)," ",0)_$S(tScale>0:".",1:"")_$P(tOutput,".",2)

	Quit tPre _ tOutput _ tPost
]]></Implementation>
</Method>

<Method name="%CopyDataFromModel">
<Description><![CDATA[
Internal method.<br>
Local implementation of DataModel API.]]></Description>
<Internal>1</Internal>
<FormalSpec>*pData,*pTypes,pSeries:%Integer=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tStatus = ..%GetQueryStatus(..%Cube,..%QueryKey)
		Set tAxisCount = ..%GetAxisCount()

		If (tAxisCount = 0) {
			// single value answer
			Set pData(1,"Result") = ..%GetValue()
			Quit
		}

		// series = column
		// prop # = row

		For a = 1:1:tAxisCount {
			Set tAxisSize(a) = ..%GetAxisSize(a)
		}

		Set tVolume = ..%GetCellCount(..%CubeKey,..%QueryKey,.tSC)
		If $$$ISERR(tSC) {
			Quit
		}
		If (tVolume = 0) {
			// no results !!!
			Quit
		}


		// Get row info: rows are properties
		Set tHasRows = 1
		Set tRowCount = +$G(tAxisSize(2))
		If (tRowCount < 1) {
			Set tRowCount = 1
		}

		For sno = $S(pSeries="":1,1:pSeries):1:..%seriesCount {
			For r = 1:1:tRowCount {
				Set tValue = $Case(tAxisCount,
					1:..%GetOrdinalValue(sno),
					:..%GetOrdinalValue(sno,r))
					Set pData(sno,r) = tValue
			}
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}

	Quit tSC
]]></Implementation>
</Method>

<Method name="%GetModelInfo">
<Description><![CDATA[
Internal method.<br>
Called by controller to get meta data for the current query.
Each metadata value is a csv list.]]></Description>
<Internal>1</Internal>
<FormalSpec>*pPropNames:%String,*pPropTypes:%Integer,*pPropLabels:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set pPropNames = ""
		Set pPropTypes = ""
		Set pPropLabels = ""

		Set tStatus = ..%GetQueryStatus(..%Cube,..%QueryKey)
		Set tAxisCount = ..%GetAxisCount()

		If (tAxisCount = 0) {
			// single value answer
			Set pPropNames = "Result"
			Set pPropTypes = 12
			Set pPropLabels = $$$Text("Result","%DeepSee")
			Quit
		}

		For a = 1:1:tAxisCount {
			Set tAxisSize(a) = ..%GetAxisSize(a)
		}

		Set tVolume = ..%GetCellCount(..%Cube,..%QueryKey,.tSC)
		If $$$ISERR(tSC) {
			Quit
		}
		If (tVolume = 0) {
			// no results !!!
			Quit
		}

		// columns are series
		Set tColCount = +$G(tAxisSize(1))
		Set ..%seriesCount = tColCount

		// column headers
		For c=1:1:$G(tAxisSize(1)) {
			Set tLabelCount = ..%GetOrdinalLabel(.tNames,1,c,.tFormat)
			Set ..%seriesNames(c) = $G(tNames(1))
		}

		// Get row info: rows are properties
		Set tHasRows = 1
		Set tRowCount = +$G(tAxisSize(2))
		If (tRowCount < 1) {
			Set tHasRows = 0
			Set tRowCount = 1
		}

		// Get names from rows
		For r = 1:1:tRowCount {
			If (tHasRows) {
				Set tName = ""
				Set tLabelCount = ..%GetOrdinalLabel(.tLabels,2,r,.tRowFormat)
				For n=tLabelCount:-1:1 {
					Set tName = tName _ $S(tName="":"",1:".")_ tLabels(n)
				}
			}
			Else {
				Set tName = $$$Text("Results","%DeepSee")
			}

			Set pPropNames = pPropNames _ $S(r=1:"",1:",") _ r
			Set pPropTypes = pPropTypes _ $S(r=1:"",1:",") _ 12
			Set pPropLabels = pPropLabels _ $S(r=1:"",1:",") _ tName
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}

	Quit tSC
]]></Implementation>
</Method>

<Method name="%GetSlicerForCellRange">
<Description><![CDATA[
Find and return an MDX slicer statement that will return the specified range of cells in
the current query as a one-cell result.<br/>
For convenience, return the measure in play, if possible to determine.]]></Description>
<FormalSpec>*pSlicer:%String,pStartRow:%Integer,pStartCol:%Integer,pEndRow:%Integer,pEndCol:%Integer,*pMeasure:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set pSlicer = ""
		Set pMeasure = ""

		Set tCubeIndex = ..%CubeKey
		Set tCubeName = $$$UPPER(..%Cube)
		Set tQueryKey = ..%QueryKey
		If ((tCubeIndex="")||(tQueryKey="")) {
			Set tSC = $$$ERROR($$$GeneralError,"Query not executed")
			Quit
		}
		If ('$D($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey))) {
			Set tSC = $$$ERROR($$$GeneralError,"No query found for key")
			Quit
		}

		// !!! what if axis count != 2
		Set tAxisCount = ..%AxisCount
		If (tAxisCount="") {
			Set tAxisCount = ..%GetAxisCount()
		}

		Set tColAxis = 1
		Set tRowAxis = 2
		Set tAxisKey = $G($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"axis",tRowAxis))

		// expression for rows
		Kill tSpecList
		For tRow = pStartRow:1:pEndRow {
			Set tNodeNo = $G($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"leaf",tRowAxis,tRow))
			If (tNodeNo="") {
				Continue
			}
			Set tNodeInfo = $G($$$DeepSeeAxisGLVN(tCubeIndex,tAxisKey,"axes",tNodeNo))
			Set tParent = $LG(tNodeInfo,4)
			Set tNodeType = $LG(tNodeInfo,1)
			Set tId = $LG(tNodeInfo,6)
			Set tKey = $LG(tNodeInfo,13)
			Set tDimNo = $LG(tNodeInfo,9)
			Set tHierNo = $LG(tNodeInfo,10)
			Set tLevelNo = $LG(tNodeInfo,11)
			If (((tNodeType="msr")||(tId'=""))&&(tDimNo '= "")&&(tHierNo '= "")&&(tLevelNo '= "")) {
				Set tMbrInfo = $G($$$DeepSeeMetaGLVN("cubes",tCubeName,"mbr#",tDimNo,tHierNo,tLevelNo))
				Set tMbrType = $LG(tMbrInfo,1)
				Set tSpec = ""
				If (tMbrType="r") {
					// tack on remote spec
					Set tRemoteSpec = $LG(tNodeInfo,14)
					If (tRemoteSpec'="") {
						Set tSpec = "["_$LG(tMbrInfo,2)_"]"_"."_tRemoteSpec
					}
				}
				ElseIf (tNodeType="msr") {
					Set pMeasure = $LG(tMbrInfo,3)
				}
				Else {
					// JMD909 - fix for drill on Properties()
					If (($LG(tMbrInfo,2)'="")&&($LG(tMbrInfo,3)'="")&&($LG(tMbrInfo,4)'="")&&(tKey'="")) {
						Set tSpec = "["_$LG(tMbrInfo,2)_"].["_$LG(tMbrInfo,3)_"].["_$LG(tMbrInfo,4)_"].&["_tKey_"]"
					}
				}

				// if any parent nodes are members, construct a tuple
				// check for relations in parents as well
				Set tIsTuple = 0
				While (tParent'="") {
					Set tPNodeInfo = $G($$$DeepSeeAxisGLVN(tCubeIndex,tAxisKey,"axes",tParent))
					Set tPNodeType = $LG(tPNodeInfo,1)
					If ((tPNodeType="mbr")||(tPNodeType="msr")) {
						Set tPType = $LG(tPNodeInfo,1)
						Set tPId = $LG(tPNodeInfo,6)
						Set tPKey = $LG(tPNodeInfo,13)
						Set tPDimNo = $LG(tPNodeInfo,9)
						Set tPHierNo = $LG(tPNodeInfo,10)
						Set tPLevelNo = $LG(tPNodeInfo,11)
						If (((tPType="msr")||(tPId'=""))&&(tPDimNo '= "")&&(tPHierNo '= "")&&(tPLevelNo '= "")) {
							// JMD1284
							Set:tSpec'="" tIsTuple = 1
							Set tPMbrInfo = $G($$$DeepSeeMetaGLVN("cubes",tCubeName,"mbr#",tPDimNo,tPHierNo,tPLevelNo))
							Set tPMbrType = $LG(tPMbrInfo,1)
							Set tPSpec = ""
							If (tPMbrType="r") {
								// tack on remote spec
								Set tRemoteSpec = $LG(tPNodeInfo,14)
								If (tRemoteSpec'="") {
									Set tPSpec = "["_$LG(tPMbrInfo,2)_"]"_"."_tRemoteSpec
								}
							}
							ElseIf (tPType="msr") {
								Set pMeasure = $LG(tPMbrInfo,3)
							}
							Else {
								// JMD909
								If (($LG(tPMbrInfo,2)'="")&&($LG(tPMbrInfo,3)'="")&&($LG(tPMbrInfo,4)'="")&&(tPKey'="")) {
									Set tPSpec = "["_$LG(tPMbrInfo,2)_"].["_$LG(tPMbrInfo,3)_"].["_$LG(tPMbrInfo,4)_"].&["_tPKey_"]"
								}
							}
							// JMD1284
							If (tPSpec'=tSpec) {
								Set:tPSpec'="" tSpec = tPSpec_$S(tSpec="":"",1:",")_tSpec
							}
						}
					}
					Set tParent = $LG(tPNodeInfo,4)
				}
				If (tIsTuple) {
					Set:tSpec'="" tSpec = "("_tSpec_")"
				}
				// JMD1284: add to list; remove duplicates
				Set:tSpec'="" tSpecList(tSpec) = ""
			}
		}

		// JMD1284: convert list to set
		Set tRowSpec = ""
		Set kc = 0
		Set tSpec = $O(tSpecList(""))
		While (tSpec'="") {
			Set kc = kc + 1
			Set tRowSpec = tRowSpec _ $S(kc>1:",",1:"") _ tSpec
			Set tSpec = $O(tSpecList(tSpec))
		}
		If (kc>1) {
			Set tRowSpec = "{" _ tRowSpec _ "}"
		}

		// expression for cols
		Kill tSpecList
		Set tAxisKey = $G($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"axis",tColAxis))

		For tCol = pStartCol:1:pEndCol {
			Set tNodeNo = $G($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"leaf",tColAxis,tCol))
			If (tNodeNo="") {
				Continue
			}
			Set tNodeInfo = $G($$$DeepSeeAxisGLVN(tCubeIndex,tAxisKey,"axes",tNodeNo))
			Set tNodeType = $LG(tNodeInfo,1)
			Set tId = $LG(tNodeInfo,6)
			Set tParent = $LG(tNodeInfo,4)
			Set tKey = $LG(tNodeInfo,13)
			Set tDimNo = $LG(tNodeInfo,9)
			Set tHierNo = $LG(tNodeInfo,10)
			Set tLevelNo = $LG(tNodeInfo,11)
			
			If (((tNodeType="msr")||(tId'=""))&&(tDimNo '= "")&&(tHierNo '= "")&&(tLevelNo '= "")) {
				Set tMbrInfo = $G($$$DeepSeeMetaGLVN("cubes",tCubeName,"mbr#",tDimNo,tHierNo,tLevelNo))
				Set tMbrType = $LG(tMbrInfo,1)
				Set tSpec = ""
				If (tMbrType="r") {
					// tack on remote spec
					Set tRemoteSpec = $LG(tNodeInfo,14)
					If (tRemoteSpec'="") {
						Set tSpec = "["_$LG(tMbrInfo,2)_"]"_"."_tRemoteSpec
					}
				}
				ElseIf (tNodeType="msr") {
					Set pMeasure = $LG(tMbrInfo,3)
				}
				Else {
					// JMD909 - fix for drill on Properties()
					If (($LG(tMbrInfo,2)'="")&&($LG(tMbrInfo,3)'="")&&($LG(tMbrInfo,4)'="")&&(tKey'="")) {
						Set tSpec = "["_$LG(tMbrInfo,2)_"].["_$LG(tMbrInfo,3)_"].["_$LG(tMbrInfo,4)_"].&["_tKey_"]"
					}
				}
				// if any parent nodes are members, construct a tuple
				Set tIsTuple = 0
				While (tParent'="") {
					Set tPNodeInfo = $G($$$DeepSeeAxisGLVN(tCubeIndex,tAxisKey,"axes",tParent))
					Set tPNodeType = $LG(tPNodeInfo,1)
					If ((tPNodeType="mbr")||(tPNodeType="msr")) {
						Set tPType = $LG(tPNodeInfo,1)
						Set tPId = $LG(tPNodeInfo,6)
						Set tPKey = $LG(tPNodeInfo,13)
						Set tPDimNo = $LG(tPNodeInfo,9)
						Set tPHierNo = $LG(tPNodeInfo,10)
						Set tPLevelNo = $LG(tPNodeInfo,11)
						If (((tPType="msr")||(tPId'=""))&&(tPDimNo '= "")&&(tPHierNo '= "")&&(tPLevelNo '= "")) {
							// JMD1284
							Set:tSpec'="" tIsTuple = 1
							Set tPMbrInfo = $G($$$DeepSeeMetaGLVN("cubes",tCubeName,"mbr#",tPDimNo,tPHierNo,tPLevelNo))
							Set tPMbrType = $LG(tPMbrInfo,1)
							Set tPSpec = ""
							If (tPMbrType="r") {
								// tack on remote spec
								Set tRemoteSpec = $LG(tPNodeInfo,14)
								If (tRemoteSpec'="") {
									Set tPSpec = "["_$LG(tPMbrInfo,2)_"]"_"."_tRemoteSpec
								}
							}
							ElseIf (tPType="msr") {
								Set pMeasure = $LG(tPMbrInfo,3)
							}
							Else {
								// JMD909
								If (($LG(tPMbrInfo,2)'="")&&($LG(tPMbrInfo,3)'="")&&($LG(tPMbrInfo,4)'="")&&(tPKey'="")) {
									Set tPSpec = "["_$LG(tPMbrInfo,2)_"].["_$LG(tPMbrInfo,3)_"].["_$LG(tPMbrInfo,4)_"].&["_tPKey_"]"
								}
							}
							// JMD1284
							If (tPSpec'=tSpec) {
								Set:tPSpec'="" tSpec = tPSpec_$S(tSpec="":"",1:",")_tSpec
							}
						}
					}
					Set tParent = $LG(tPNodeInfo,4)
				}
				If (tIsTuple) {
					Set:tSpec'="" tSpec = "("_tSpec_")"
				}
				// JMD1284: add to list; remove duplicates
				Set:tSpec'="" tSpecList(tSpec) = ""
			}
		}

		// JMD1284: convert list to set
		Set tColSpec = ""
		Set kc = 0
		Set tSpec = $O(tSpecList(""))
		While (tSpec'="") {
			Set kc = kc + 1
			Set tColSpec = tColSpec _ $S(kc>1:",",1:"") _ tSpec
			Set tSpec = $O(tSpecList(tSpec))
		}
		If (kc>1) {
			Set tColSpec = "{" _ tColSpec _ "}"
		}

		Set tWHERE = ""
		If ((tRowSpec '= "")&&(tColSpec '= "")) {
			// !!! Set tWHERE = "NONEMPTYCROSSJOIN(" _ tRowSpec _ "," _ tColSpec _ ")"
			Set tWHERE = "CROSSJOIN(" _ tRowSpec _ "," _ tColSpec _ ")"
		}
		ElseIf (tRowSpec '= "") {
			Set tWHERE = tRowSpec
		}
		ElseIf (tColSpec '= "") {
			Set tWHERE = tColSpec
		}

		Set tSlicer = $G($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"slicer"))
		If (tSlicer '= "") {
			If (tWHERE = "") {
				Set tWHERE = tSlicer
			}
			Else {
				Set tWHERE = "CROSSJOIN(" _ tWHERE _ "," _ tSlicer _ ")"
			}

			// check for measure in slicer (simple case)
			If (pMeasure="") {
				If (tSlicer [ "[MEASURES].") {
					Set pMeasure = $P(tSlicer,"[MEASURES].",2,999)
					Set pMeasure = $P(pMeasure,"]",1)
					Set:$E(pMeasure)="[" pMeasure = $P(pMeasure,"[",2)
				}
			}
		}
		Set pSlicer = tWHERE
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%GetFiltersForCellRange">
<Description><![CDATA[
Find and return a an array of MDX %FILTER statements that will return the specified range of cells in
the current query as a one-cell result.<br/>
On return, <var>pFilters</var> will contain the filter statement corresponding to each axis (1,2, etc) and the slicer
(0).<br/>
For convenience, return the measure in play, if possible to determine.<br/>]]></Description>
<FormalSpec>*pFilters:%String,pStartRow:%Integer,pStartCol:%Integer,pEndRow:%Integer,pEndCol:%Integer,*pMeasure:%String,pAllRows:%Boolean=0,pAllCols:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Kill pFilters
		Set pMeasure = ""

		Set tCubeIndex = ..%CubeKey
		Set tCubeName = $$$UPPER(..%Cube)
		Set tQueryKey = ..%QueryKey
		If ((tCubeIndex="")||(tQueryKey="")) {
			Set tSC = $$$ERROR($$$GeneralError,"Query not executed")
			Quit
		}
		If ('$D($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey))) {
			Set tSC = $$$ERROR($$$GeneralError,"No query found for key")
			Quit
		}

		// we only support 2 axes
		Set tAxisCount = ..%AxisCount
		If (tAxisCount="") {
			Set tAxisCount = ..%GetAxisCount()
		}
		Set tColAxis = 1
		Set tRowAxis = 2
		Set tAxisKey = $G($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"axis",tRowAxis))

		// expression for rows
		Set tItems = 0
		Set tRowSpec = ""
		If ('pAllRows) {
			For tRow = pStartRow:1:pEndRow {
				Set tNodeNo = $G($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"leaf",tRowAxis,tRow))
				If (tNodeNo="") {
					Continue
				}
				Set tNodeInfo = $G($$$DeepSeeAxisGLVN(tCubeIndex,tAxisKey,"axes",tNodeNo))
				Set tDone = 0
				While ('tDone) {
					Set tDone = 1
					Set tNodeType = $LG(tNodeInfo,1)
					Set tAggType = $LG(tNodeInfo,6)
					If ((tNodeType="agg")&&(tAggType'="%KPI")&&(tAggType'="%MDX")) {
						// visit children of this node
						Set tLoopChildren = 1
						Set tChildNodeNo = $O($$$DeepSeeAxisGLVN(tCubeIndex,tAxisKey,"axes",tNodeNo,"ch",""))
					
						// n.b. for COUNT:EXCLUDEEMPTY we should add special processing here to find
						// only the members that are contributing
					}
					ElseIf ((tNodeType="exp")||((tNodeType="agg")&&((tAggType="%KPI")||(tAggType="%MDX")))) {
						// JMD913
						// move up to parent of this node
						Set tNodeNo = $LG(tNodeInfo,4)
						Set tNodeInfo = $G($$$DeepSeeAxisGLVN(tCubeIndex,tAxisKey,"axes",tNodeNo))
						Set tDone = 0
					}
					Else {
						Set tLoopChildren = 0
					}
				}

				While((tLoopChildren=0)||(tChildNodeNo'="")) {
					If (tLoopChildren) {
						Set tNodeInfo = $G($$$DeepSeeAxisGLVN(tCubeIndex,tAxisKey,"axes",tChildNodeNo))
						Set tNodeType = $LG(tNodeInfo,1)
					}

					Set tParent = $LG(tNodeInfo,4)
					Set tId = $LG(tNodeInfo,6)
					Set tKey = $LG(tNodeInfo,13)
					Set tDimNo = $LG(tNodeInfo,9)
					Set tHierNo = $LG(tNodeInfo,10)
					Set tLevelNo = $LG(tNodeInfo,11)

					If (((tNodeType="msr")||(tId'=""))&&(tDimNo '= "")&&(tHierNo '= "")&&(tLevelNo '= "")) {
						Set tMbrInfo = $G($$$DeepSeeMetaGLVN("cubes",tCubeName,"mbr#",tDimNo,tHierNo,tLevelNo))
						Set tMbrType = $LG(tMbrInfo,1)
						Set tSpec = ""
						If (tMbrType="r") {
							Set tNullRef = $G($$$DeepSeeMetaGLVN("cubes",tCubeName,"relations",$$$UPPER($LG(tMbrInfo,2)),"nullReplacement"))
							If ((tNullRef'="")&&(tId=-1E14)) {
								// no relation
								Set tSpec = "["_$LG(tMbrInfo,2)_"]"_".["_tNullRef_"]"
							}
							Else {
								// tack on remote spec
								Set tRemoteSpec = $LG(tNodeInfo,14)
								If (tRemoteSpec'="") {
									Set tSpec = "["_$LG(tMbrInfo,2)_"]"_"."_tRemoteSpec
								}
								// special case for drilldown
								If ($$$UPPER($P(tSpec,".",$L(tSpec,".")))="CHILDREN") {
									Set tSpec = $P(tSpec,".",1,$L(tSpec,".")-1)
									Set:tKey'="" tSpec = tSpec _ ".&[" _ tKey _ "]"
								}
							}
						}
						ElseIf (tNodeType="msr") {
							Set pMeasure = $LG(tMbrInfo,3)
						}
						Else {
							// JMD909 - fix for drill on Properties()
							If (($LG(tMbrInfo,2)'="")&&($LG(tMbrInfo,3)'="")&&($LG(tMbrInfo,4)'="")&&(tKey'="")) {
								Set tSpec = "["_$LG(tMbrInfo,2)_"].["_$LG(tMbrInfo,3)_"].["_$LG(tMbrInfo,4)_"].&["_tKey_"]"
							}
						}

						// if any parent nodes are members, construct a tuple
						// check for relations in parents as well
						Set tIsTuple = 0
						While (tParent'="") {
							Set tPNodeInfo = $G($$$DeepSeeAxisGLVN(tCubeIndex,tAxisKey,"axes",tParent))
							Set tPNodeType = $LG(tPNodeInfo,1)
							If ((tPNodeType="mbr")||(tPNodeType="msr")) {
								Set tPType = $LG(tPNodeInfo,1)
								Set tPId = $LG(tPNodeInfo,6)
								Set tPKey = $LG(tPNodeInfo,13)
								Set tPDimNo = $LG(tPNodeInfo,9)
								Set tPHierNo = $LG(tPNodeInfo,10)
								Set tPLevelNo = $LG(tPNodeInfo,11)
								If (((tPType="msr")||(tPId'=""))&&(tPDimNo '= "")&&(tPHierNo '= "")&&(tPLevelNo '= "")) {
									Set tIsTuple = 1
									Set tPMbrInfo = $G($$$DeepSeeMetaGLVN("cubes",tCubeName,"mbr#",tPDimNo,tPHierNo,tPLevelNo))
									Set tPMbrType = $LG(tPMbrInfo,1)
									Set tPSpec = ""
									If (tPMbrType="r") {
										// tack on remote spec
										Set tRemoteSpec = $LG(tPNodeInfo,14)
										// JMD976
										If (tPId=-1E14) {
											// no relation
											Set tPSpec = "["_$LG(tPMbrInfo,2)_"]"_".&[<null>]"
										}
										ElseIf (tRemoteSpec'="") {
											Set tPSpec = "["_$LG(tPMbrInfo,2)_"]"_"."_tRemoteSpec
										}
									}
									ElseIf (tPType="msr") {
										Set pMeasure = $LG(tPMbrInfo,3)
									}
									Else {
										// JMD909
										If (($LG(tPMbrInfo,2)'="")&&($LG(tPMbrInfo,3)'="")&&($LG(tPMbrInfo,4)'="")&&(tPKey'="")) {
											Set tPSpec = "["_$LG(tPMbrInfo,2)_"].["_$LG(tPMbrInfo,3)_"].["_$LG(tPMbrInfo,4)_"].&["_tPKey_"]"
										}
									}
									Set:tPSpec'="" tSpec = tPSpec_","_tSpec
								}
							}
							Set tParent = $LG(tPNodeInfo,4)
						}
						If (tIsTuple) {
							Set:tSpec'="" tSpec = "("_tSpec_")"
						}
						Set tRowSpec = tRowSpec _ $S(tRowSpec="":"",1:",") _ tSpec
						If ($L(tRowSpec)>5000) {
							// JMD836: too many items: ignore restriction
							Set tItems = 0
							Set tRowSpec = ""
							Quit
						}
						Set tItems = tItems + 1
					}
					If (tLoopChildren) {
						Set tChildNodeNo = $O($$$DeepSeeAxisGLVN(tCubeIndex,tAxisKey,"axes",tNodeNo,"ch",tChildNodeNo))
					}
					Else {
						Quit
					}
				} // while()
			}
			If (tItems > 1) {
				Set:tRowSpec'="" tRowSpec = "{" _ tRowSpec _ "}"
			}
		}

		// expression for cols
		Set tItems = 0
		Set tColSpec = ""
		If ('pAllCols) {
			Set tAxisKey = $G($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"axis",tColAxis))
			For tCol = pStartCol:1:pEndCol {
				Set tNodeNo = $G($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"leaf",tColAxis,tCol))
				If (tNodeNo="") {
					Continue
				}
				Set tNodeInfo = $G($$$DeepSeeAxisGLVN(tCubeIndex,tAxisKey,"axes",tNodeNo))
				Set tDone = 0
				While ('tDone) {
					Set tDone = 1
					Set tNodeType = $LG(tNodeInfo,1)
					Set tAggType = $LG(tNodeInfo,6)
					If ((tNodeType="agg")&&(tAggType'="%KPI")&&(tAggType'="%MDX")) {
						// visit children of this node
						Set tLoopChildren = 1
						Set tChildNodeNo = $O($$$DeepSeeAxisGLVN(tCubeIndex,tAxisKey,"axes",tNodeNo,"ch",""))
					}
					ElseIf ((tNodeType="exp")||((tNodeType="agg")&&((tAggType="%KPI")||(tAggType="%MDX")))) {
						// JMD913
						// move up to parent of this node
						Set tNodeNo = $LG(tNodeInfo,4)
						Set tNodeInfo = $G($$$DeepSeeAxisGLVN(tCubeIndex,tAxisKey,"axes",tNodeNo))
						Set tDone = 0
					}
					Else {
						Set tLoopChildren = 0
					}
				}

				While((tLoopChildren=0)||(tChildNodeNo'="")) {
					If (tLoopChildren) {
						Set tNodeInfo = $G($$$DeepSeeAxisGLVN(tCubeIndex,tAxisKey,"axes",tChildNodeNo))
						Set tNodeType = $LG(tNodeInfo,1)
					}

					Set tId = $LG(tNodeInfo,6)
					Set tParent = $LG(tNodeInfo,4)
					Set tKey = $LG(tNodeInfo,13)
					Set tDimNo = $LG(tNodeInfo,9)
					Set tHierNo = $LG(tNodeInfo,10)
					Set tLevelNo = $LG(tNodeInfo,11)
			
					If (((tNodeType="msr")||(tNodeType="lit")||(tId'=""))&&(tDimNo '= "")&&(tHierNo '= "")&&(tLevelNo '= "")) {
						Set tMbrInfo = $G($$$DeepSeeMetaGLVN("cubes",tCubeName,"mbr#",tDimNo,tHierNo,tLevelNo))
						Set tMbrType = $LG(tMbrInfo,1)
						Set tSpec = ""
						If (tMbrType="r") {
							Set tNullRef = $G($$$DeepSeeMetaGLVN("cubes",tCubeName,"relations",$$$UPPER($LG(tMbrInfo,2)),"nullReplacement"))
							If ((tNullRef'="")&&(tId=-1E14)) {
								// no relation
								Set tSpec = "["_$LG(tMbrInfo,2)_"]"_".["_tNullRef_"]"
							}
							Else {
								// tack on remote spec
								Set tRemoteSpec = $LG(tNodeInfo,14)
								If (tRemoteSpec'="") {
									Set tSpec = "["_$LG(tMbrInfo,2)_"]"_"."_tRemoteSpec
								}
								// special case for drilldown
								If ($$$UPPER($P(tSpec,".",$L(tSpec,".")))="CHILDREN") {
									Set tSpec = $P(tSpec,".",1,$L(tSpec,".")-1)
									Set:tKey'="" tSpec = tSpec _ ".&[" _ tKey _ "]"
								}
							}
						}
						ElseIf (tNodeType="msr") {
							Set pMeasure = $LG(tMbrInfo,3)
						}
						Else {
							// JMD909 - fix for drill on Properties()
							If (($LG(tMbrInfo,2)'="")&&($LG(tMbrInfo,3)'="")&&($LG(tMbrInfo,4)'="")&&(tKey'="")) {
								Set tSpec = "["_$LG(tMbrInfo,2)_"].["_$LG(tMbrInfo,3)_"].["_$LG(tMbrInfo,4)_"].&["_tKey_"]"
							}
						}
						// if any parent nodes are members, construct a tuple
						Set tIsTuple = 0
						While (tParent'="") {
							Set tPNodeInfo = $G($$$DeepSeeAxisGLVN(tCubeIndex,tAxisKey,"axes",tParent))
							Set tPNodeType = $LG(tPNodeInfo,1)
							If ((tPNodeType="mbr")||(tPNodeType="msr")) {
								Set tPType = $LG(tPNodeInfo,1)
								Set tPId = $LG(tPNodeInfo,6)
								Set tPKey = $LG(tPNodeInfo,13)
								Set tPDimNo = $LG(tPNodeInfo,9)
								Set tPHierNo = $LG(tPNodeInfo,10)
								Set tPLevelNo = $LG(tPNodeInfo,11)
								If (((tPType="msr")||(tPId'=""))&&(tPDimNo '= "")&&(tPHierNo '= "")&&(tPLevelNo '= "")) {
									Set tIsTuple = 1
									Set tPMbrInfo = $G($$$DeepSeeMetaGLVN("cubes",tCubeName,"mbr#",tPDimNo,tPHierNo,tPLevelNo))
									Set tPMbrType = $LG(tPMbrInfo,1)
									Set tPSpec = ""
									If (tPMbrType="r") {
										// tack on remote spec
										Set tRemoteSpec = $LG(tPNodeInfo,14)
										If (tRemoteSpec'="") {
											Set tPSpec = "["_$LG(tPMbrInfo,2)_"]"_"."_tRemoteSpec
										}
									}
									ElseIf (tPType="msr") {
										Set pMeasure = $LG(tPMbrInfo,3)
									}
									Else {
										// JMD909
										If (($LG(tPMbrInfo,2)'="")&&($LG(tPMbrInfo,3)'="")&&($LG(tPMbrInfo,4)'="")&&(tPKey'="")) {
											Set tPSpec = "["_$LG(tPMbrInfo,2)_"].["_$LG(tPMbrInfo,3)_"].["_$LG(tPMbrInfo,4)_"].&["_tPKey_"]"
										}
									}
									Set:tPSpec'="" tSpec = tPSpec_","_tSpec
								}
							}
							Set tParent = $LG(tPNodeInfo,4)
						}
						If (tIsTuple) {
							Set:tSpec'="" tSpec = "("_tSpec_")"
						}
						Set tColSpec = tColSpec _ $S(tColSpec="":"",1:",") _ tSpec
						If ($L(tColSpec)>5000) {
							// JMD836: too many items: ignore restriction
							Set tItems = 0
							Set tColSpec = ""
							Quit
						}
						Set tItems = tItems + 1
					}
					If (tLoopChildren) {
						Set tChildNodeNo = $O($$$DeepSeeAxisGLVN(tCubeIndex,tAxisKey,"axes",tNodeNo,"ch",tChildNodeNo))
					}
					Else {
						Quit
					}
				} // while
			}
			If (tItems > 1) {
				Set:tColSpec'="" tColSpec = "{" _ tColSpec _ "}"
			}
		}

		Set tSlicer = $G($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"slicer"))
		If (tSlicer '= "") {
			// check for measure in slicer (simple case)
			If (pMeasure="") {
				If (tSlicer [ "[MEASURES].") {
					Set pMeasure = $P(tSlicer,"[MEASURES].",2,999)
					Set pMeasure = $P(pMeasure,"]",1)
					Set:$E(pMeasure)="[" pMeasure = $P(pMeasure,"[",2)
				}
			}
		}
		Set:tColSpec'="" pFilters(1) = tColSpec
		Set:tRowSpec'="" pFilters(2) = tRowSpec
		Set:tSlicer'="" pFilters(0) = tSlicer
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%OutputXMLA">
<Description><![CDATA[
Output the result of the current query in XML/A 
format to the current device. The query should be prepared
and executed first.<br/>
If there is an error, it is assumed that the caller will transform
the status value into a SOAP fault.]]></Description>
<Internal>1</Internal>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tCubeName = $$$UPPER(..%Cube)
		Set tCubeIndex = ..%CubeKey		
		Set tQueryKey = ..%QueryKey
		Set tStatus = ..%GetQueryStatus(tCubeName,tQueryKey)
		Set tAxisCount = ..%GetAxisCount()
		For a = 1:1:tAxisCount {
			Set tAxisSize(a) = ..%GetAxisSize(a)
			Set tAxisKeys(a) = $G($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"axis",a))
		}

		If (..%Query.queryType = "DRILLTHROUGH") {
			// !!! what to do for DRILLTHROUGH
			Quit
		}

		// find name of cube in original case
		Set tCubeClass = $G($$$DeepSeeMetaGLVN("cubes",tCubeName))
		Set tCubeName = $G($$$DeepSeeMetaGLVN("classes",tCubeClass))

		// timestamps !!!
		Set tLastDataUpdate = $G($$$DeepSeeMetaGLVN("cubes",tCubeName,"lastDataUpdate"))
		Set tLastSchemaUpdate = $G($$$DeepSeeMetaGLVN("cubes",tCubeName,"lastSchemaUpdate"))

		If (tLastDataUpdate'="") {
			// format is: "2009-06-19T15:55:31"
			Set tLastDataUpdate = $TR($ZDT(tLastDataUpdate,3)," ","T")
		}
		If (tLastSchemaUpdate'="") {
			// format is: "2009-06-19T15:55:31"
			Set tLastSchemaUpdate = $TR($ZDT(tLastSchemaUpdate,3)," ","T")
		}


		// Cube section
		&html<
<root xmlns="urn:schemas-microsoft-com:xml-analysis:mddataset" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
<OlapInfo>
<CubeInfo>
<Cube>
<CubeName>#($ZCVT(tCubeName,"O","XML"))#</CubeName>
<LastDataUpdate xmlns="http://schemas.microsoft.com/analysisservices/2003/engine">#(tLastDataUpdate)#</LastDataUpdate>
<LastSchemaUpdate xmlns="http://schemas.microsoft.com/analysisservices/2003/engine">#(tLastSchemaUpdate)#</LastSchemaUpdate>
</Cube>
</CubeInfo>
		>

		// Additional OLAP info

		// Axes info
		&html<<AxesInfo>>
		For a = 1:1:tAxisCount {
			&html<<AxisInfo name="Axis#(a-1)#">>
			// !!!
			&html<</AxisInfo>>
		}
		&html<</AxesInfo>>

		// Cell info
		&html<
<CellInfo>
<Value name="VALUE"/>
<FmtValue name="FORMATTED_VALUE" type="xsd:string"/>
<CellOrdinal name="CELL_ORDINAL" type="xsd:unsignedInt"/>
</CellInfo>
		>

		&html<</OlapInfo>>

		// Results


		// Axes section
		// !!! what if there are 0 axes
		// !!! what about the slicer
		&html<<Axes>>
		For a = 1:1:tAxisCount {
			// for each axis write out the tuples that make up each entry
			&html<<Axis name="Axis#(a-1)#">>
			&html<<Tuples>>
			Set tAxisKey = tAxisKeys(a)

			// walk down leaf index and get node #s for this axis
			Set tItemNo = $O($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"leaf",a,""),1,tNodeNo)
			While (tItemNo '= "") {
				&html<<Tuple>>
				// use node number to get details for the axis node
				// (this comes from the axis cache)
				Set tNode = $G($$$DeepSeeAxisGLVN(tCubeIndex,tAxisKey,"axes",tNodeNo))

				// look up the chain of parents for this node to see what belongs to
				// this *tuple*; assemble a list of nodes
				Kill tNodes
				Set tLevel = 0
				Set tParentNo = $LG(tNode,4)
				Set tParentNode = tNode
				While (tParentNo '= "") {
					Set tType = $LG(tParentNode,1)
					If ((tType = "mbr")||(tType = "msr")||(tLevel=0)) {
						Set tLevel = tLevel + 1
						Set tNodes(tLevel) = tParentNode
					}
					Set tParentNode = $G($$$DeepSeeAxisGLVN(tCubeIndex,tAxisKey,"axes",tParentNo))
					Set tParentNo = $LG(tParentNode,4) // go up
				}

				// walk down list of nodes and emit members for this tuple
				For n = tLevel:-1:1 {
					Set tNode = tNodes(n)
					// pull details out of node
					Set tType = $LG(tNode,1)
					Set tCaption = $LG(tNode,5)
					Set tMbrId = $LG(tNode,6)
					Set tDimNo = +$LG(tNode,9)
					Set tHierNo = +$LG(tNode,10)
					Set tLevelNo = +$LG(tNode,11)

					If ('$D(tMbrInfoCache(tDimNo,tHierNo,tLevelNo),tMbrInfo)) {
						// Avoid going to the meta global by using local cache
						Set tMbrInfo = $G($$$DeepSeeMetaGLVN("cubes",tCubeName,"mbr#",tDimNo,tHierNo,tLevelNo))
						Set tMbrInfoCache(tDimNo) = tMbrInfo
					}

					If (tType = "msr") {
						Set tDimName = "[Measures]"
						Set tLevelName = "["_tCaption_"]"
						Set tUName = tDimName_".["_tCaption_"]"
					}
					Else {
						Set tDimName = "["_$LG(tMbrInfo,2)_"]"
						Set tHierName = "["_$LG(tMbrInfo,3)_"]"
						Set tLevelName = "["_$LG(tMbrInfo,4)_"]"
					
						// compute uname
						Set tUName = ""
						Set tDimClass = $LG(tMbrInfo,6)
						If (tDimClass'="") {
							Set tUName = $zobjclassmethod(tDimClass,"%GetMemberSpec",tMbrId,tCubeName,tDimNo,tHierNo,tLevelNo)
						}
						Set tUName = tDimName_"."_tHierName_"."_tUName
					}
				
					Set tDispInfo = 0 // !!!

					&html<<Member Hierarchy="#($ZCVT(tDimName,"O","XML"))#">>
					&html<<UName>#($ZCVT(tUName,"O","XML"))#</UName>>
					&html<<Caption>#($ZCVT(tCaption,"O","XML"))#</Caption>>
					&html<<LName>#($ZCVT(tLevelName,"O","XML"))#</LName>>
					&html<<LNum>#($ZCVT(tLevelNo,"O","XML"))#</LNum>>
					&html<<DisplayInfo>#($ZCVT(tDispInfo,"O","XML"))#</DisplayInfo>>
					&html<</Member>>
				}

				// end of this tuple
				&html<</Tuple>>
				//Set tItemNo = $O($$$DeepSeeResultsGLVN(tCubeKey,tQueryKey,"leaf",a,tItemNo),1,tNodeNo)

				Set tItemNo = $O($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"leaf",a,tItemNo),1,tNodeNo)
			} 

			&html<</Tuples>>
			&html<</Axis>>
		}
		&html<</Axes>>

		// Cells
		&html<<CellData>>

		// Write out cells in order
		// Initial cell address
		Set tCellNo = 0
		For a=1:1:tAxisCount {
			Set tAxisKey = tAxisKeys(a)
			
			//Set tItemNo(a) = $O($$$DeepSeeResultsGLVN(tCubeKey,tQueryKey,"leaf",a,""),1,tNodeNo)
			Set tItemNo(a) = $O($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"leaf",a,""),1,tNodeNo)
			Set tAddr(a) = tNodeNo
		}
		Set tDone = 0
		While ('tDone) {
		Set tValue = $Case(tAxisCount,
			0:..%GetValue(),
			1:..%GetValue(tAddr(1)),
			2:..%GetValue(tAddr(1),tAddr(2)),
			3:..%GetValue(tAddr(1),tAddr(2),tAddr(3)),
			4:..%GetValue(tAddr(1),tAddr(2),tAddr(3),tAddr(4)),
			5:..%GetValue(tAddr(1),tAddr(2),tAddr(3),tAddr(4),tAddr(5)),
			6:..%GetValue(tAddr(1),tAddr(2),tAddr(3),tAddr(4),tAddr(5),tAddr(6)),
			7:..%GetValue(tAddr(1),tAddr(2),tAddr(3),tAddr(4),tAddr(5),tAddr(6),tAddr(7)),
			:"")
			
			// determine type of the value
			// !!!! n.b, we need to find the actual format string to apply
			// for now we guess
			If ($IsValidNum(tValue)) {
				If (tValue = (tValue\1)) {
					Set tType = "xsd:long"
					Set tFmtValue = $FN(tValue,",",0)
				}
				Else {
					Set tType = "xsd:double"
					Set tFmtValue = $FN(tValue,",",2)
				}
			}
			Else {
				Set tType = "xsd:string"
			}
			&html<<Cell CellOrdinal="#(tCellNo)#"><Value xsi:type="#(tType)#">#(tValue)#</Value><FmtValue>#(tFmtValue)#</FmtValue></Cell>>
			Set tCellNo = tCellNo + 1

			// find next cell tCubeIndex
			Set tFoundNext = 0
			Set a = 1
			While ('tFoundNext) {
				//Set tItemNo(a) = $O($$$DeepSeeResultsGLVN(tCubeKey,tQueryKey,"leaf",a,tItemNo(a)),1,tNodeNo)
				Set tItemNo(a) = $O($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"leaf",a,tItemNo(a)),1,tNodeNo)
				If (tItemNo(a) '= "") {
					Set tAddr(a) = tNodeNo
					Set tFoundNext = 1
				}
				Else {
					//Set tItemNo(a) = $O($$$DeepSeeResultsGLVN(tCubeKey,tQueryKey,"leaf",a,""),1,tNodeNo)
					Set tItemNo(a) = $O($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"leaf",a,""),1,tNodeNo)
					Set tAddr(a) = tNodeNo
					Set a = a + 1
					If (a > tAxisCount) {
						Set tDone = 1
						Quit
					}
				}
			}
		}

		&html<</CellData>>
		&html<</root>>
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%GetDefaultFormat">
<Description>
Return the default format string for this result.
Also returns the default label (measure name).</Description>
<Internal>1</Internal>
<FormalSpec>*pCaption:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set pCaption = ""
	Set tCubeIndex = ..%CubeKey
	Set tQueryKey = ..%QueryKey

	#; determine default format
	Set tDefaultFormat = ""
	Set tSlicer = $G($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"slicer"))
	If (tSlicer'="") {
		Set tSlicerKey = $G($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"axis",0))
		If (tSlicerKey'="") {
			Set s = $O($$$DeepSeeAxisGLVN(tCubeIndex,tSlicerKey,"axes",1,"all",""))
			If (s'="") {
				Set tSNode = $G($$$DeepSeeAxisGLVN(tCubeIndex,tSlicerKey,"axes",s))
				If ($LG(tSNode,1)="msr") {
					Set tDefaultFormat = $LG(tSNode,12)
					Set pCaption = $LG(tSNode,5)
				}
			}
		}
	}
	If (pCaption="") {
		Set pCaption = ##class(%DeepSee.Utils).%GetCountCaption(tCubeIndex)
	}

	Quit tDefaultFormat
]]></Implementation>
</Method>

<Method name="%OutputJSON">
<Description><![CDATA[
Output the result of the current query in XML/A 
format to the current device. The query should be prepared
and executed first.<br/>
If there is an error, it is assumed that the caller will transform
the status value into a SOAP fault.]]></Description>
<Internal>1</Internal>
<FormalSpec>pPageSize:%Integer,pCurrPage:%Integer,pRowLabels:%List="",pMaxRows:%Integer=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tCubeIndex = ..%CubeKey
		Set tCubeName = $$$UPPER(..%Cube)
		Set tQueryKey = ..%QueryKey
		Set tStatus = ..%GetQueryStatus(..%Cube,tQueryKey)
		If (tStatus < 100) {
			// wait a bit!
			Hang 1
			// try again
			Set tStatus = ..%GetQueryStatus(..%Cube,tQueryKey)
		}

		If (tStatus < 100) {
			Write "null",!
			Quit
		}

		// window
		Set tMaxCols = 500
		Set tStartRow = ((pCurrPage-1)*pPageSize)+1
		Set tEndRow = tStartRow + pPageSize - 1
		Set tRowCount = 0
		Set tColCount = 0

		// write out *all* rows and let the client page through the results
		// meta data consists of an array of up to 2 axes.
		// Each axis has list of tuples: {c:caption,f:format}
		// these correspond to leaf nodes.
		// and a graph of groups that refer to the tuples:
		// groups:[{caption:'',groups:[...],tuples:[]

		// data consists of a single array of values (cells: q.v.)

		Set tAxisCount = ..%GetAxisCount()
		For a = 1:1:tAxisCount {
			Set tAxisSize(a) = ..%GetAxisSize(a)
			Set tAxisKeys(a) = $G($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"axis",a))
		}

		Set tColCount = +$G(tAxisSize(1))
		Set tRowCount = +$G(tAxisSize(2))
		// JMD1128 
		Set tMaxJSONRows = $S(pMaxRows="":2000,1:+pMaxRows)
		Set:tRowCount>tMaxJSONRows tRowCount = tMaxJSONRows
		Set:tColCount>tMaxCols tColCount = tMaxCols

		Set tStartRow = 1
		Set tEndRow = tStartRow + tRowCount - 1

		If (..%Query.queryType = "DRILLTHROUGH") {
			Write "null",!
			Quit
		}	

		#; determine default format
		Set tDefaultFormat = ..%GetDefaultFormat(.tDefaultCaption)

		// find name of cube in original case
		Set tCubeClass = $G($$$DeepSeeMetaGLVN("cubes",tCubeName))
		Set tCubeName = $G($$$DeepSeeMetaGLVN("classes",tCubeClass))

		Write "{"
		Write !,$$$ZENJSPAIR("cubeName",tCubeName),","
		Write !,$$$ZENJSPAIR("cubeClass",tCubeClass),","
		Write !,$$$ZENJSPAIR("defaultFormat",tDefaultFormat),","
		Write !,$$$ZENJSPAIR("defaultCaption",tDefaultCaption),","

		// row level captions
		Write !,"""rowCaptions"":[",!
		Set rc = $O(pRowLabels(""))
		While (rc'="") {
			Write $$$ZENJSVALUE(pRowLabels(rc))
			Set rc = $O(pRowLabels(rc))
			Write:rc'="" ","
		}
		Write "],",! // rowCaptions

		Write !,"""axes"":[",!

		// ?JMD- should we write out tuples post-json?
		If (tAxisCount = 0) {
			// default axes
			Write "{" // axis object
			Write """key"":","null",",",!
			Write """tuples"":[",!
				Set tCaption = "All"
				Write "{" // tuple object
				Write $$$ZENJSPAIR("caption",tCaption)
				Write "}",! // tuple object
			Write "]",! // tuples
			Write "}",! // axis object

			Write ",{",! // axis object
			Write """key"":","null",",",!
			Write """tuples"":[",!
				Set tCaption = "Count"
				Write "{",! // tuple object
				Write $$$ZENJSPAIR("caption",tCaption)
				Write "}",! // tuple object
			Write "]",! // tuples
			Write "}",! // axis object
		}

		// axis info
		For a = 1:1:tAxisCount {
			Set tAxisKey = tAxisKeys(a)
			Set tHasGroups = 0

			// JMD1128: construct set of groups within this axis
			Set tGroupCount = 1	// node # in groups graph
			Kill tGroups		// group info by number, with hierarchy as graph
								// leaf nodes contain leaf #
			Kill tGroupIndex 	// node # to group #

			Write:a>1 ","
			Write "{" // axis object
			Write !,$$$ZENJSPAIR("key",tAxisKey),","
			Write !,"""tuples"":[",!

			// walk down leaf index and get node #s for this axis
			// make sure we only write out values for current page
			If (a = 2) {
				Set tStart = tStartRow
				Set tEnd = tEndRow
			}
			Else {
				Set tStart = 1
				Set tEnd = tMaxCols
			}

			Set n = 0 // items written
			Set item = 0 // actual item #
			Set tItemNo = $O($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"leaf",a,""),1,tNodeNo)
			While ((tItemNo '= "")&&(item<tEnd)) {
				Set item = item + 1
				If (item >= tStart) {
					// use node number to get details for the axis node
					// (this comes from the axis cache)
					Set tNode = $G($$$DeepSeeAxisGLVN(tCubeIndex,tAxisKey,"axes",tNodeNo))

					Set tType = $LG(tNode,1)
					Set tParent = $LG(tNode,4)
					Set tCaption = $LG(tNode,5)
					Set tMbrId = $LG(tNode,6)
					Set tDimNo = +$LG(tNode,9)
					Set tHierNo = +$LG(tNode,10)
					Set tLevelNo = +$LG(tNode,11)
					Set tFmt = $LG(tNode,12)
					Set tGroupNo = ""

					// JMD: test if we are showing a date value;
					// these may need to be reformatted on the client
					Set tKey = ""
					Set tDateType = ""
					If ((tDimNo'="")&&(tHierNo'="")&&(tLevelNo'="")) {
						If '$D(tMbrTypes(tDimNo,tHierNo,tLevelNo)) {
							Set tDimInfo = $G($$$DeepSeeMetaGLVN("cubes",tCubeIndex,"mbr#",tDimNo,tHierNo,tLevelNo))
							Set tTimeClass = $LG(tDimInfo,6)
							Set tDType = ""
							// n.b. use the level class to guess the type
							If (tTimeClass = "%DeepSee.Time.Year") {
								// Set tDType = "year" -- no need
							}
							ElseIf (tTimeClass = "%DeepSee.Time.MonthYear") {
								Set tDType = "month"
							}
							ElseIf (tTimeClass = "%DeepSee.Time.QuarterYear") {
								Set tDType = "quarter"
							}
							ElseIf (tTimeClass = "%DeepSee.Time.WeekYear") {
								// Set tDType = "week" // ignore for now
							}
							ElseIf (tTimeClass = "%DeepSee.Time.DayMonthYear") {
								Set tDType = "day"
							}
							Set tMbrTypes(tDimNo,tHierNo,tLevelNo) = tDType
						}
						Set tDateType = $G(tMbrTypes(tDimNo,tHierNo,tLevelNo))
					}
					Set:tDateType'="" tKey = $LG(tNode,13)

					// JMD1128: test if we are part of a group
					If (tParent'="") {
						If $D(tGroupIndex(tParent)) {
							// point to existing group
							Set tGroupNo = tGroupIndex(tParent)
						}
						Else {
							// build list of parents above this node
							Kill tPList
							Set pn = 0
							While (tParent'="") {
								Set tParentNode = $G($$$DeepSeeAxisGLVN(tCubeIndex,tAxisKey,"axes",tParent))
								Set tParentType = $LG(tParentNode,1)
								If ((tParentType="mbr")||(tParentType="msr")) {
									Set tHasGroups = 1
									Set tPList(pn) = tParent
									Set pn = pn + 1
								}
								Set tParent = $LG(tParentNode,4)
							}

							// now walk down the list
							Set tLastParent = 0
							Set pn = $O(tPList(""),-1)
							While (pn'="") {
								Set tParent = tPList(pn)
								If $D(tGroupIndex(tParent)) {
									Set gc = tGroupIndex(tParent)
								}
								Else {
									Set gc = tGroupCount
									Set tGroupCount = tGroupCount + 1
								}
								Set tGroupIndex(tParent) = gc
								Set tGroups(gc) = tParent
								Set tGroups(tLastParent,"ch",gc) = ""
								Set tLastParent = gc
								Set tGroupNo = gc
								Set pn = $O(tPList(pn),-1)
							}
						}
					}

					Set n = n + 1
					If (tGroupNo'="") {
						Set tGroups(tGroupNo,"leaf",n) = ""
					}

					Write:n>1 ","
					Write "{" // tuple object
					Write $$$ZENJSPAIR("caption",tCaption)
					Write:tDateType'="" ",", $$$ZENJSPAIR("type",tDateType)
					Write:tKey'="" ",", $$$ZENJSPAIR("key",tKey)
					Write:tGroupNo'="" ",",$$$ZENJSPAIR("g",tGroupNo)
					Write:tFmt'="" ",",$$$ZENJSPAIR("format",tFmt)
					Write "}",! // tuple object
				}
				Set tItemNo = $O($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"leaf",a,tItemNo),1,tNodeNo)
			}
			Write "]" // tuples

			Write ",""hasGroups"":",$S(tHasGroups:"true",1:"false"),!

			// JMD1128: groups and children
			If $D(tGroups) {
				//Do ..%OutputAxisGroupJSON(.tGroups,0,tCubeIndex,tAxisKey)
				// JMD1148: write out flat list of groups
				Write ",""groups"":["
				Set gn = 0
				Set g = $O(tGroups(""))
				While (g'="") {
					Set tCaption = ""
					Set tParentNo = ""
					Set tNodeNo = $G(tGroups(g))
					If (tNodeNo'="") {
						Set tGroupNode = $G($$$DeepSeeAxisGLVN(tCubeIndex,tAxisKey,"axes",tNodeNo))
						Set tCaption = $LG(tGroupNode,5)
						Set tParentNo = $LG(tGroupNode,4)
					}
					Set gn = gn + 1
					Write:gn>1 ","
					Write "{" // group object
					Write:tCaption'="" $$$ZENJSPAIR("caption",tCaption),","
					If (tParentNo'="") {
						Set tParentGroup = $G(tGroupIndex(tParentNo))
						Write:tParentGroup'="" $$$ZENJSPAIR("g",tParentGroup),","
					}
					If $D(tGroups(g,"ch")) {
						Write """groups"":["
						Set gc = $O(tGroups(g,"ch",""))
						While (gc'="") {
							Write gc
							Set gc = $O(tGroups(g,"ch",gc))
							Write:gc'="" ","
						}
						Write "],"
					}
					If $D(tGroups(g,"leaf")) {
						Write """tuples"":["
						Set gc = $O(tGroups(g,"leaf",""))
						While (gc'="") {
							Write gc
							Set gc = $O(tGroups(g,"leaf",gc))
							Write:gc'="" ","
						}
						Write "]"
					}
					Write "}",! // group object

					Set g = $O(tGroups(g))
				}
				Write "]",!

			}

			Write "}",! // axis object
		}

		Write "],",! // axes


		// Initial cell address
		For a=1:1:tAxisCount {
			Set tAxisKey = tAxisKeys(a)
			Set tItemNo(a) = $O($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"leaf",a,""),1,tNodeNo)
			Set tAddr(a) = $G(tNodeNo)
		}

		// write out size of data;
		// this allows us to use 1 array for all data values

		Write $$$ZENJSPAIR("rowCount",tRowCount),",",!
		Write $$$ZENJSPAIR("columnCount",tColCount),",",!

		// cells
		// note: we only write out up to 2D results as our client has no use for
		// higher order information
		// JMD1148: simplify JSON for data
		// fastest way is to not use pure JSON!
		// instead, define an array of known-size and explicitly insert values into it.
		// data is written out as [R1C1,R1C2,R1C3,R2C1,R2C2,R2C3]
		Write """cells"":[],",!

		Write """rowTotals"":[],",!
		Write """columnTotals"":[],",!

		Write $$$ZENJSPAIR("grandTotal",+$G($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"total"))),",",!

		Write $$$ZENJSPAIR("status",tStatus),! // last property
		Write "}"

		// JMD1148: violate JSON rules for speed's sake:
		Write ";",!

		// cells
		Write "var a = new Array(",tRowCount*tColCount,");",!
		Write "o.data.cells = a;",!

		If (tAxisCount = 0) {
			Write "a[0]="_$$$ZENJSVALUE(..%GetValue())_";",!
		}
		ElseIf (tAxisCount = 1) {
			Set tRowCount = 1
			Set c = 0
			While((tItemNo(1)'="")&&(c<tMaxCols)) {
				Write "a["_c_"]="_$$$ZENJSVALUE(..%GetValue(tAddr(1)))_";",!
				Set c = c + 1
				Set tItemNo(1) = $O($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"leaf",1,tItemNo(1)),1,tNodeNo)
				Set tAddr(1) = tNodeNo
			}
		}
		Else {
			Set tCellCount = 0
			Set row = 0 // actual row #
			While((tItemNo(2)'="")&&(row<tEndRow)) {
				Set row = row + 1
				If (row >= tStartRow) {
					Set c = 0
					Set tItemNo(1) = $O($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"leaf",1,""),1,tNodeNo)
					Set tAddr(1) = tNodeNo
					While((tItemNo(1)'="")&&(c<tMaxCols)) {
						Set c = c + 1
						Set tValue = $Case(tAxisCount,
							0:..%GetValue(),
							1:..%GetValue(tAddr(1)),
							2:..%GetValue(tAddr(1),tAddr(2)),
							3:..%GetValue(tAddr(1),tAddr(2),tAddr(3)),
							4:..%GetValue(tAddr(1),tAddr(2),tAddr(3),tAddr(4)),
							5:..%GetValue(tAddr(1),tAddr(2),tAddr(3),tAddr(4),tAddr(5)),
							6:..%GetValue(tAddr(1),tAddr(2),tAddr(3),tAddr(4),tAddr(5),tAddr(6)),
							7:..%GetValue(tAddr(1),tAddr(2),tAddr(3),tAddr(4),tAddr(5),tAddr(6),tAddr(7)),
							:"")
						Write "a["_tCellCount_"]="_$$$ZENJSVALUE(tValue)_";",!
						Set tCellCount = tCellCount + 1

						Set tItemNo(1) = $O($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"leaf",1,tItemNo(1)),1,tNodeNo)
						Set tAddr(1) = tNodeNo
					}
				}
				Set tItemNo(2) = $O($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"leaf",2,tItemNo(2)),1,tNodeNo)
				Set tAddr(2) = tNodeNo
			}
		}

		// row "totals"
		Write "var a = new Array(",tRowCount,");",!
		Write "o.data.rowTotals = a;",!

		Set r = 0 // rows written
		For tRow = 1:1:tRowCount {
			Write "a["_r_"]="
			Set r = r + 1
			If $D($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"total",2,tRow)) {
				Write "{"
				Write $$$ZENJSPAIR("count",$G($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"total",2,tRow,"count"))),","
				Write $$$ZENJSPAIR("sum",$G($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"total",2,tRow,"sum"))),","
				Write $$$ZENJSPAIR("min",$G($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"total",2,tRow,"min"))),","
				Write $$$ZENJSPAIR("max",$G($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"total",2,tRow,"max"))),","
				Write $$$ZENJSPAIR("avg",$G($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"total",2,tRow,"avg"))),","
				Write $$$ZENJSPAIR("pct",$G($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"total",2,tRow,"pct")))
				Write "};",!
			}
			Else {
				Write "null;",!
			}
		}

		// column "totals"
		Write "var a = new Array(",tColCount,");",!
		Write "o.data.columnTotals = a;",!

		For tCol = 1:1:tColCount {
			Write "a["_(tCol-1)_"]="

			If $D($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"total",1,tCol)) {
				Write "{"
				Write $$$ZENJSPAIR("count",$G($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"total",1,tCol,"count"))),","
				Write $$$ZENJSPAIR("sum",$G($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"total",1,tCol,"sum"))),","
				Write $$$ZENJSPAIR("min",$G($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"total",1,tCol,"min"))),","
				Write $$$ZENJSPAIR("max",$G($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"total",1,tCol,"max"))),","
				Write $$$ZENJSPAIR("avg",$G($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"total",1,tCol,"avg"))),","
				Write $$$ZENJSPAIR("pct",$G($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"total",1,tCol,"pct")))
				Write "};",!
			}
			Else {
				Write "null;",!
			}
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
		Write "/*"
		Do $System.OBJ.DisplayError(tSC)
		Write "*/"
	}
	Quit tSC
]]></Implementation>
</Method>
</Class>
</Export>
