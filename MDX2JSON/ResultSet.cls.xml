<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="25">
<Class name="MDX2JSON.ResultSet">
<Description><![CDATA[
This class provides an API for executing queries against DeepSee cubes 
and viewing the results.<br/>]]></Description>
<IncludeCode>MDX2JSON.MDX2JSON</IncludeCode>
<Super>%DeepSee.ResultSet</Super>
<TimeCreated>63463,69237.325048</TimeCreated>

<Method name="ToProxyObject">
<Description><![CDATA[
Converts ResultSet to %ZEN.proxyObject.<br>
<b>pStatus</b> - Status of execution.<br>]]></Description>
<FormalSpec>*pStatus:%Status</FormalSpec>
<ReturnType>%ZEN.proxyObject</ReturnType>
<Implementation><![CDATA[
    set status = $$$ERROR($$$GeneralError,"Error occured while executing ##class(MDX2JSON.ResultSet).ToProxyObject() method")
       
    set obj=##class(%ZEN.proxyObject).%New()
    
    if (..%Query.queryType = "DRILLTHROUGH") {
        set pStatus = $$$ERROR($$$GeneralError, "DRILLTHROUGH queries are not supported")
        return ""
    }
        
    set tQueryKey = ..%QueryKey
    
	set st = ..%GetQueryStatus(..%Cube,tQueryKey)
	if (st < 100) {
	    hang 1
	    set st = ..%GetQueryStatus(..%Cube,tQueryKey)
	}

	if (st < 100) {
	    set pStatus = st
	    return ""
	}
	
	try {                                       
	    set obj.Info = ..InfoToProxyObject() // basic info about cube and query
	    set obj.Cols = ..AxesToProxyObject() // all axes
	    set obj.Data = ..DataToProxyObject() // array of all cells, left-to-right, up-to-down
	} catch ex {
		set pStatus = ex.AsStatus()
		return ""
	}
	set pStatus = $$$OK
    return obj
]]></Implementation>
</Method>

<Method name="InfoToProxyObject">
<Description>
Returns meta-information about ResultSet.</Description>
<ReturnType>%ZEN.proxyObject</ReturnType>
<Implementation><![CDATA[
	set tCubeIndex = ..%CubeKey
	set tQueryKey = ..%QueryKey
	set tCubeName = $$$UPPER(..%Cube)

	set tAxisCount = ..%GetAxisCount()
	for a = 1:1:tAxisCount {
	    set tAxisSize(a) = ..%GetAxisSize(a)
	    set tAxisKeys(a) = $G($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"axis",a))
	}
	
	set tColCount = $G(tAxisSize(1))
	set tRowCount = $G(tAxisSize(2))

	// find name of cube in original case
	set tCubeClass = $G($$$DeepSeeMetaGLVN("cubes",tCubeName))
	set tCubeName = $G($$$DeepSeeMetaGLVN("classes",tCubeClass))
																	
																	
	set info=##class(%ZEN.proxyObject).%New()
	
	set info.cubeName = tCubeName
	set info.cubeClass = tCubeClass
	set info.rowCount = tRowCount
	set info.colCount = tColCount																																	 
														    
    return info
]]></Implementation>
</Method>

<Method name="AxesToProxyObject">
<Description>
Returns array of Axes</Description>
<ReturnType>%ListOfObjects</ReturnType>
<Implementation><![CDATA[
    set tCubeIndex = ..%CubeKey
    set tQueryKey = ..%QueryKey
    
    if ($System.Version.GetMajor() >=2015) {
    	set tAxisCount = ..%GetAxisCount()
    } else {
	    set tAxisCount = 2 //because filters count as axes before 2015.1
    }

    set axes=##class(%ListOfObjects).%New()
    
	for a = 1:1:tAxisCount {
        set tAxisSize(a) = ..%GetAxisSize(a)
        set tAxisKeys(a) = $G($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"axis",a))
        do axes.Insert(..ProcessOneAxis(tCubeIndex,tAxisKeys(a),a))
    }

    return axes
]]></Implementation>
</Method>

<Method name="ProcessOneAxis">
<Internal>1</Internal>
<FormalSpec>CubeIndex,AxisKey,AxisNumber</FormalSpec>
<ReturnType>%ZEN.proxyObject</ReturnType>
<Implementation><![CDATA[
	set tCubeName = $$$UPPER(..%Cube)
    set tQueryKey = ..%QueryKey
	
    set axis=##class(%ZEN.proxyObject).%New()
    //d ##class(%DeepSee.Utils).%GetDimensionCaption(tCubeName,1, tHierNo,tLevelNo, .tAxisCaption)
    
    //set axis.caption = $zobjclassmethod($G($$$DeepSeeMetaGLVN("cubes",tCubeName)),"%GetMemberCaption",$$$UPPER(tDimName))
    //set axis.spec = $G($$$DeepSeeAxisGLVN(CubeIndex,AxisKey,"spec"))
    
    set axis.tuples = ..ProcessOneAxisCell(CubeIndex, AxisKey, tCubeName, tQueryKey, AxisNumber, 1)
       
    return axis
]]></Implementation>
</Method>

<Method name="ProcessOneAxisCell">
<Internal>1</Internal>
<FormalSpec>CubeIndex,AxisKey,CubeName,QueryKey,AxisNumber,Node</FormalSpec>
<ReturnType>%ZEN.proxyObject</ReturnType>
<Implementation><![CDATA[
    set cell=##class(%ZEN.proxyObject).%New()
        
    set tNode = $G($$$DeepSeeAxisGLVN(CubeIndex,AxisKey,"axes",Node))
    set tDimNo = $LG(tNode,9)
    set tHierNo = $LG(tNode,10)
    set tLevelNo = $LG(tNode,11)

	set cell.caption = $LG(tNode,5) // text caption
    set cell.format = $LG(tNode,12) // format for numbers, eg: $## ###.## 
    set cell.total = $LG(tNode,8) //COUNT,AVG function
    set cell.type = $LG(tNode,1) // mbr,cmbr,lit
    set cell.valueID = $LG(tNode,6) // id in mdx dimension for mbr, path for cmbr
    set cell.path = ##class(%DeepSee.Query.Engine).%GetSpecForAxisNode(CubeName, QueryKey, AxisNumber, Node) // MDX cell path
    
    set info = $LG(tNode,18)
	set cell.info = info // expected structure is property1:value1;property2:value2;...;propertyN:valueN;
	
	if info'="" { // extract aggregation information, leave the rest as css	
		set summaryposition = $f(info,"summary")
		if summaryposition>0 {
			set summaryvalue = $e(info,summaryposition+1,$f(info,";",summaryposition)-2)
			set cell.summary = summaryvalue // aggregate function
			set $e(info,summaryposition-7,summaryposition + $l(summaryvalue) + 1) = "" 
		}
		set cell.style = info // css
		
		/*for i=1:1:($L(cell.info,";")-1) { 
		set part = $P(cell.info,";",i)
		set property = $P(part,":",1)
		set value = $P(part,":",2)
		do cell.%DispatchSetProperty(property, value)
		}*/
	}

    do ##class(%DeepSee.Utils).%GetDimensionCaption(CubeName,tDimNo, tHierNo,tLevelNo, .tAxisCaption)
    set cell.dimension = tAxisCaption // cube dimension
        
    // now we process cell children, if any exist
    if ($D($$$DeepSeeAxisGLVN(CubeIndex, AxisKey, "axes", Node, "ch")) = 10) {
        set cell.children = ##class(%ListOfObjects).%New()
        set key = $O($$$DeepSeeAxisGLVN(CubeIndex, AxisKey, "axes", Node, "ch", ""))
        while (key'="") {
            set children = ..ProcessOneAxisCell(CubeIndex, AxisKey, CubeName, QueryKey, AxisNumber, key)
            // Append children to cell
            if (children.%IsA("%ZEN.proxyObject")) {
                do cell.children.Insert(children)
            } elseif (children.%IsA("%Collection.AbstractList")) {
                for i=1:1:children.Count() {
                    do cell.children.Insert(children.GetAt(i))
                }
            }
            
            set key = $O($$$DeepSeeAxisGLVN(CubeIndex, AxisKey, "axes", Node, "ch", key))
        }
        

        // To filter out invisible top-level сells
        if (..IsCellNull(cell.caption, cell.path)=1) {
            return cell.children    
        }
    } 

    return cell
]]></Implementation>
</Method>

<Method name="IsCellNull">
<Description>
Determine if cell is an invisyble system cell.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>caption,path</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	return:(caption=0) 1
	return:(caption=1) 1
	return:(caption="") 1
	return:(caption'="") 0
	return:(path="") 1
	return 0
]]></Implementation>
</Method>

<Method name="DataToProxyObject">
<Description>
Returns array of cells (left-to-right, up-to-down)</Description>
<ReturnType>%ListOfDataTypes</ReturnType>
<Implementation><![CDATA[
	set data = ##class(%ListOfDataTypes).%New()
	
	set tCubeIndex = ..%CubeKey
    set tQueryKey = ..%QueryKey
	set tAxisCount = ..%GetAxisCount()
	set tAddr = tAxisCount
	
	set tNodeNo = ""
	
	// Initial cell address
	for a=1:1:tAxisCount {
		Set tItemNo(a) = $O($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"leaf",a,""),1,tNodeNo)
		Set tAddr(a) = $G(tNodeNo)
	}

	set tNodeNo = ""
	
	if (tAxisCount = 1) {
		set tRowCount = 1
		set c = 0
		while (tItemNo(1)'="") {
			do data.Insert(..%GetValue(tAddr(1)))
			set c = c + 1
			set tItemNo(1) = $O($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"leaf",1,tItemNo(1)),1,tNodeNo)
			set tAddr(1) = tNodeNo
		}
	}
	else {
		set tCellCount = 0
		while(tItemNo(2)'="") {
				set tItemNo(1) = $O($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"leaf",1,""),1,tNodeNo)
				set tAddr(1) = tNodeNo
				while (tItemNo(1)'="") {
					set tValue = ..%GetValue(tAddr...) // for 2 axes ..%GetValue(tAddr(1),tAddr(2))
					do data.Insert(tValue)

					set tItemNo(1) = $O($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"leaf",1,tItemNo(1)),1,tNodeNo)
					set tAddr(1) = tNodeNo
				}
			set tItemNo(2) = $O($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"leaf",2,tItemNo(2)),1,tNodeNo)
			set tAddr(2) = tNodeNo
		}
	}

	return data
]]></Implementation>
</Method>
</Class>
</Export>
