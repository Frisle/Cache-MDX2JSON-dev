<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="25">
<Class name="MDX2JSON.Utils">
<Description><![CDATA[
Utility class, wrapping processing of MDX queries.<br>
Outputs JSON, JSONP and XML/A.]]></Description>
<IncludeCode>%ZEN.Utils</IncludeCode>
<Super>%RegisteredObject</Super>
<TimeCreated>63165,65653.547419</TimeCreated>

<Parameter name="NAMESPACE">
<Default>TFOMS</Default>
</Parameter>

<Method name="WriteJSONfromMDX">
<Description><![CDATA[
Automatic processing of MDX query and outputting resulting JSON.<br>
<b>pMDX</b> - String containing MDX query.<br>
Returns NULL if there is an error in MDX query.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pMDX:%String</FormalSpec>
<ProcedureBlock>1</ProcedureBlock>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    set Params = ""
    #dim st As %Status = $$$OK
    set RS = ##class(MDX2JSON.ResultSet).%ExecuteDirect(pMDX,.Params,.st)
       
    if $$$ISERR(st) {
	    write "{Error:"_$$$ZENJSSTR($System.Status.GetErrorText(st))_"}"
	    return $$$OK
    }
    
    set obj = RS.ToProxyObject()
    w $e(obj.%ToJSON(),1,*-1) // status
    
    return $$$OK
]]></Implementation>
</Method>

<Method name="WriteJSONPfromMDX">
<Description><![CDATA[
Automatic processing of MDX query and outputting resulting JSONP.<br>
<b>pMDX</b> - String containing MDX query.<br>
Returns NULL if there is an error in MDX query.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pMDX:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    zn ..#NAMESPACE
    try {
        set PageSize = 1000
        set CurrPage = 1
        set Params = ""
        set RS = ##class(%DeepSee.ResultSet).%New()
        #dim st As %Status = $$$OK
        set RS = ##class(%DeepSee.ResultSet).%ExecuteDirect(pMDX,.Params,st)
        do RS.%OutputJSON(PageSize,CurrPage,,PageSize)
    } catch ex {
        set st = ex.AsStatus()
    }
    quit st
]]></Implementation>
</Method>

<Method name="WriteDrillthroughJSON">
<Description><![CDATA[
Automatic processing of MDX Drillthrough query and outputting resulting listing as JSON.<br>
<b>pMDX</b> - String containing MDX Drillthrough query.<br>
Returns NULL if there is an error in MDX query.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pMDX:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    try {
        set Params = ""
        set RS = ##class(%DeepSee.ResultSet).%New()
        #dim st As %Status = $$$OK
        set RS = ##class(%DeepSee.ResultSet).%ExecuteDirect(pMDX,.Params,st)
        set SQL = RS.%GetListingSQL()
        do ##class(%ZEN.Auxiliary.jsonSQLProvider).%WriteJSONFromSQL(,SQL,,$$$MaxCacheInt)
    } catch ex {
        set st = ex.AsStatus()
    }
    quit st
]]></Implementation>
</Method>

<Method name="WriteXMLAfromMDX">
<Description><![CDATA[
Automatic processing of MDX query and outputting resulting XML/A.<br>
<b>pMDX</b> - String containing MDX query.<br>
Returns NULL if there is an error in MDX query.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pMDX:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    try {
        set Params = ""
        set RS = ##class(%DeepSee.ResultSet).%New()
        #dim st As %Status = $$$OK
        set RS = ##class(%DeepSee.ResultSet).%ExecuteDirect(pMDX,.Params,st)
        set st = RS.%OutputXMLA()
    } catch ex {
        set st = ex.AsStatus()
    }
    quit st
]]></Implementation>
</Method>

<Method name="WriteFiltersForMDX">
<Description><![CDATA[
Gets filters for MDX expression.<br>
<b>pMDX</b> - String containing MDX query.<br>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pMDX:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    zn ..#NAMESPACE
    try {
        set Params = ""
        set filters= ""
        set measure=""
        set RS = ##class(%DeepSee.ResultSet).%New()
        #dim st As %Status = $$$OK
        set RS = ##class(%DeepSee.ResultSet).%ExecuteDirect(pMDX,.Params,st)
        set st1=RS.%GetFiltersForCellRange(.filters,0,0,RS.%GetAxisSize(2),RS.%GetAxisSize(1),.measure)
        zw filters
    } catch ex {
        set st = ex.AsStatus()
    }
    quit st
]]></Implementation>
</Method>

<Method name="WriteFiltersForCube">
<Description><![CDATA[
Get all filters for DeepSee Cube in JSON format.<br>
<b>pCube</b> - name of DeepSee cube.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCube:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    zn ..#NAMESPACE
    try {
        #dim st As %Status = $$$OK
        set st = ##class(%DeepSee.Dashboard.Utils).%GetFiltersForDataSource(pCube_".cube",.tFilters)
        do ##class(%ZEN.Auxiliary.jsonProvider).%ArrayToJSON($lb("name","path","info"),.tFilters)
    } catch ex {
        set st = ex.AsStatus()
    }
    quit st
]]></Implementation>
</Method>

<Method name="WriteFilterValues">
<Description><![CDATA[
Get all values for Filter for DeepSee Cube in JSON format.<br>
<b>pCube</b> - name of DeepSee cube.<br>
<b>pFilter</b> - path of filter. For example: [DateOfSale].[Actual].[MonthSold]]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCube:%String,pFilter:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    try {
        #dim st As %Status = $$$OK
        set st = ##class(%DeepSee.Dashboard.Utils).%GetMembersForFilter(pCube,pFilter,.tFilters,.tDefaultFilterValue,,.tRelatedFilters,0,,.tValueList)
        do ##class(%ZEN.Auxiliary.jsonProvider).%ArrayToJSON($lb("name","value"),.tFilters)
    } catch ex {
        set st = ex.AsStatus()
    }
    return st
]]></Implementation>
</Method>

<Method name="GetMdx">
<ClassMethod>1</ClassMethod>
<FormalSpec>pPivotName:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  	set pMdx =""
 	set st = $$$OK
  	try {
	   set tPivot = ##class(%DeepSee.UserLibrary.Utils).%OpenFolderItem(pPivotName,.st)
	   return:$$$ISERR(st) st
	   
	   set tPivotTable = ##class(%DeepSee.Component.pivotTable).%New()
	   set st = tPivot.%CopyToComponent(tPivotTable)
	   return:$$$ISERR(st) st
	   
	   set rs = tPivotTable.%CreateResultSet(.st,.tParms,.tFilterInfo,.tAdvancedFilters,.tQueryText)
	   return:$$$ISERR(st) st
	   
	   set pMdx = tQueryText
  	} catch ex {
   		set st = ex.AsStatus()
  	}
  	return pMdx
]]></Implementation>
</Method>

<Method name="GetWidgetsList">
<ClassMethod>1</ClassMethod>
<FormalSpec>pDashName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set st = $$$OK
	try {
		
		&sql(
			SELECT TOP 1 ID into :tDashId
			FROM %DeepSee_Dashboard.Definition
			WHERE fullName=:pDashName
		)
		return:(SQLCODE'=0) $$$ERROR($$$SQLError, SQLCODE)

		set dash = ##class(%DeepSee.Dashboard.Definition).%OpenId(tDashId,,.st)

		return:($$$ISERR(st)) st
		set widgets = dash.widgets.%ConstructClone("true")
		//Widget : {type,  title, mdx}

		set widget = widgets.GetNext(.key)
		
		do {
			set out(key) =$lb(widget.subtype, widget.title, ..GetMdx(widget.dataSource))
			set widget = widgets.GetNext(.key)
		} while (key'="")

		do ##class(%ZEN.Auxiliary.jsonProvider).%ArrayToJSON($lb("type","title","mdx"),.out)
		
	} catch ex {
		set st = ex.AsStatus()
	}
	return st
]]></Implementation>
</Method>

<Method name="Export">
<Description>
Export project
do ##class(MDX2JSON.Utils).Export()</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    
    Set st=$system.OBJ.Export("MDX2JSON.ResultSet.cls,MDX2JSON.REST.cls,MDX2JSON.Utils.cls,","/InterSystems/Cache2014/csp/sys/mdx2json "_$ZSTRIP($ZDT($NOW(),3,2),"*",":-")_".xml")
    Return st
]]></Implementation>
</Method>
</Class>
</Export>
